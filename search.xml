<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LeetCode 154. MinArray(Easy)]]></title>
    <url>%2F2020%2F08%2F18%2FLeetCode-154-MinArray%2F</url>
    <content type="text"><![CDATA[题目把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。 来源LeetCode练习 示例示例 1： 12输入：[3,4,5,1,2]输出：1 示例 2： 12输入：[2,2,2,0,1]输出：0 解题思路根据题意我们可以得知在进行数组的旋转之前这是一个递增数组并且可能含有重复数字. 最容易想到的方法: 1. 暴力法我们从数组的第一个元素开始进行遍历将前后进行对比,如果numbers[left] &gt; numbers[right]则已经出现转折(前后分别是两个不同的可能递增的数组).此时right就是我们要找的最小的元素下标.返回numbers[right]即可.也有可能全部数组都是重复的一个数字,我们在进行遍历结束后都没有找到符合条件的numbers[left]&gt;numbers[right]我们就直接返回数组的一个数(默认下标为0的数) 2. 二分法我们在进行传统的二分查找时候,数组必须是要有序的,因为此时我们才能对于一个数进行对比后判断要找的数在它的左区间或者右区间.以便减少查找的次数. 而在本题中其实是满足的二分法的(因为在分界处两边都是单调的数组),我们需要找的就是找到这个分界处. 例如示例1中: ​ 我们取2个下标left,right(默认为第一个和最后一个),然后得到中间下标mid(mid = left + (right - left)/2)—这里有个小细节:我们得到中间的数不是用的(left + right)/2 因为这样当left和right很大的时候相加会出现溢出. 其实后面除以2 我更愿意改成 &gt;&gt; 1 因为位运算更快.)所以进行一个循环条件是(left &lt; right) 当number[mid] &gt;number[right]的时候说明mid前面是一个递增的,临界处在mid的右边,将left指针移动到mid+1处 当number[mid] &lt; number[right]的时候说明mid右边是一个递增的,临界处在mid的左边,所以将right指针指向mid处即可 当number[mid] = number[right] 的时候说明数组里面有重复的数字,我们不清楚临界处是在mid的左边还是右边,我们需要做的是将right--即可. 最后返回number[right] 代码1. 暴力法12345678910111213141516class Solution &#123; public int minArray(int[] numbers) &#123; if(numbers.length == 0) return 0; int res = 0; for(int i = 0; i &lt; numbers.length; i++)&#123; int left = i; int right = left + 1; if(right == numbers.length) break; if(numbers[left] &gt; numbers[right])&#123; res = right; break; &#125; &#125; return numbers[res]; &#125;&#125; 2. 二分法12345678910111213141516public static int minArray(int[] numbers) &#123; int i = 0; int j = numbers.length - 1; if(numbers[i] &lt; numbers[j] || numbers.length == 1) return numbers[i]; while (i &lt; j) &#123; int mid = i + (j - i)/2; if(numbers[mid] &lt;= numbers[j])&#123; j = mid; &#125;else if(numbers[mid] &gt; numbers[j])&#123; i = mid + 1; &#125;else &#123; j--; &#125; &#125; return numbers[j]; &#125;]]></content>
      <categories>
        <category>study</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构之图(Graph)]]></title>
    <url>%2F2020%2F08%2F15%2F%E5%9B%BE-Graph%2F</url>
    <content type="text"><![CDATA[概念简单来说，图是一种用来表示相连数据的数据结构，类似我们的社交网络，图中有很多的节点，每个节点代表一个数据，每个节点可以和其他节点相连。其中每个节点叫做顶点（vertice）,连接顶点之间的线叫做相连线（edge） img 在此图中，我们含有5个顶点和6条相连线，每个顶点包含了人名，而连接线代表相连人名之间是朋友关系。如果我们要更正式地表示图，那么图就可以用一对（V，E）集合来表示，其中V是一堆顶点的集合，而E是一堆相连线的集合 V = {a,b,c,d,e} E={ab,ac,,bd,cd,de} 上述是无向图 图的分类有三种: 无向图 有向图 权重图 无向图比较容易理解,连线没有方向,有向图则是存在连线方向的(可以理解成账号之间的关注问题,若A指向B,则表示A关注了B,若B也关注了A,则存在双向箭头),而权重图则是连线之间有值(可以理解成朋友之间的亲密度值). 其中有向图使用的比较多. 有向图的表示邻接矩阵 img 每行代表相应的顶点，如果M[i][j] = 1，那么就代表顶点 i 连向 j，如果是0，则表达顶点间没有联系. 优点:可以很清楚的知道两个顶点是否相连 缺点:因为我们要浪费很多空间来保存没有关联的两个点的信息.用矩阵实现的时间复杂度很高，我们需要O(V^2)来记录所有的数据 邻接表针对邻接矩阵的缺点,我们可以采用邻接表的方式来只保存有关系的两个点(通过链表实现) img Java实现代码: 12345678910111213141516171819202122232425import java.util.ArrayList;/** * @Auther: zy * @Date: 2020/8/15 14:32 * @Description: 图的实现(链表) */public class ListGraph &#123; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; graphs; public ListGraph(int val)&#123; graphs = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; val; i++) &#123; graphs.add(new ArrayList&lt;&gt;()); &#125; &#125; public void addEdge(int start,int end)&#123; graphs.get(start).add(end); &#125; public void removeEdge(int start,int end)&#123; graphs.get(start).remove((Integer) end); &#125;&#125; 有向图的实现很简单，我们直接使用Java中的ArrayList来代表左侧的数组和数组上的链表，其中两个重要方法addEdge和removeEdge直接使用ArrayList自带的方法add和remove即可。使用链表的形式来实现图，我们可以只记录有用的数据，省下了很多空间 图的遍历图的遍历方式有两种,一种是深度优先搜索（Depth-first Search），另一种是宽度优先搜索（Breadth-first search） DFS(深度优先搜索)图的深度优先搜索跟树的先序遍历很类似.在深度优先遍历中，我们假设初始状态所有顶点都没被访问，然后从每一顶点v出发，先访问该顶点，然后依次从它的各个未被访问的邻接点出发，深度优先遍历图，直到图中所有和v相通的顶点都被访问到。若遍历完后，还有其他顶点没被访问到，则另选一个未被访问的顶点作为起始点，重复上述过程，直到所有顶点都被访问完为止 img 具体的遍历顺序 1234567访问A访问B（在访问A之后，接下来应该访问的是A出发的另一个顶点，既顶点B）访问C（在访问B之后，接下来访问的是从B出发的另一个顶点，既C，E，F。在此图中，我们按照字母排序顺序访问，因此先访问C。）访问E（接下来访问与C连接的另一个顶点E。）访问D（接下来访问从E出发的顶点B和D，因为B已被访问过，所以访问顶点D。）访问F（接下来回溯“访问A的另一个连接顶点F”）访问G BFS(广度优先搜索)广度优先搜索算法也叫做“宽度优先搜索”或“横向优先搜索”,它跟树的层次遍历有些类似,其方法是从图中的某一顶点v出发，在访问了v之后依次访问v的各个没有访问到的邻接点，然后分别从这些邻接点出发依次访问他们的邻接点，使得先被访问的顶点的邻接点先与后被访问顶点的邻接点被访问，直到图中所有已被访问的顶点的邻接点都被访问到。如果此时图中尚有顶点未被访问，则需要另选一个未曾被访问到的顶点作为新的起始点，重复上述过程，直至图中所有顶点都被访问到为止。换句话说，广度优先搜索遍历图的过程是以v为起点，由近至远，依次访问和v有路径相通且路径长度为1，2，…的顶点 img 具体的遍历顺序: 1234访问A访问B依次访问C，E，F（在B被访问之后，接下来访问B的邻接点，既C，E，F。）依次访问D，G（在访问完C，E，F之后，再依次访问他们出发的另一个顶点。还是按照C，E，F的顺序访问，C的已经全部访问过了，那么就只剩下E，E；先访问E的邻接点D，再访问F的邻接点G。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899package com.enoch.algorithm.graph;import java.util.ArrayDeque;import java.util.Deque;import java.util.Iterator;/** * @Auther: zy * @Date: 2020/8/15 14:37 * @Description: 图的遍历(DFS,BFS) */public class GraphTraversal &#123; ListGraph graph; //遍历过的值 boolean[] visited; public GraphTraversal(ListGraph listGraph)&#123; this.graph = listGraph; visited = new boolean[listGraph.graphs.size()]; &#125; public void DFS()&#123; for (int i = 0; i &lt; graph.graphs.size(); i++) &#123; if(!visited[i])&#123; DFSTraversal(i); &#125; &#125; &#125; public void BFS()&#123; for (int i = 0; i &lt; graph.graphs.size(); i++) &#123; if(!visited[i])&#123; BFSTraversal(i); &#125; &#125; &#125; public void DFSTraversal(int v)&#123; //判断是否访问过 if(visited[v]) return; //将该点加入已访问的boolean数组中 visited[v] = true; System.out.print(v + "-&gt;"); //通过listIterator遍历拿到该节点的相邻节点集合 Iterator&lt;Integer&gt; neighbors = graph.graphs.get(v).listIterator(); while (neighbors.hasNext())&#123; // 循环遍历该节点的相邻节点并递归访问 int nextNode = neighbors.next(); if(!visited[nextNode])&#123; DFSTraversal(nextNode); &#125; &#125; &#125; public void BFSTraversal(int v)&#123; if(visited[v]) return; // 创建一个双向队列来保存某节点的相邻节点 // 使用队列的原因是因为一个节点的相邻节点比下一个节点的相邻节点要先访问(符合 队列的先进先出) Deque&lt;Integer&gt; queue = new ArrayDeque&lt;&gt;(); visited[v] = true; queue.addFirst(v); while(!queue.isEmpty())&#123; Integer cur = queue.pollFirst(); System.out.print(cur + "-&gt;"); Iterator&lt;Integer&gt; neighbors = graph.graphs.get(cur).listIterator(); while (neighbors.hasNext())&#123; Integer nextNode = neighbors.next(); // 每一次访问该节点后把该节点的相邻节点 添加到队列的尾部 if(!visited[nextNode])&#123; queue.offerLast(nextNode); visited[nextNode] = true; &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; ListGraph listGraph = new ListGraph(8); listGraph.addEdge(1,2); listGraph.addEdge(2,3); listGraph.addEdge(2,4); listGraph.addEdge(2,5); listGraph.addEdge(3,5); listGraph.addEdge(4,7); listGraph.addEdge(5,2); listGraph.addEdge(5,6); listGraph.addEdge(6,3); GraphTraversal graphTraversal = new GraphTraversal(listGraph); graphTraversal.BFS(); &#125;&#125;]]></content>
      <categories>
        <category>study</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Graph</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 105. buildTree(Medium)]]></title>
    <url>%2F2020%2F08%2F13%2FLeetCode-105-buildTree%2F</url>
    <content type="text"><![CDATA[题目该是出自剑指Offer 输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 在线练习LeetCode : https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/ 牛客网: https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6?tpId=13&amp;&amp;tqId=11157&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking 示例:12前序遍历 preorder = [3,9,20,15,7]中序遍历 inorder = [9,3,15,20,7] 返回的二叉树 12345 3 / \9 20 / \ 15 7 解题思路根据前序遍历的性质，第一个元素必然就是root，那么下面的工作就是如何确定root的左右子树的范围 根据中序遍历的性质，root元素前面都是root的左子树，后面都是root的右子树.那么我们只要找到中序遍历中root的位置，就可以确定好左右子树的范围 而我们每次就可以通过前序中序之间的关系确定: 前序: 根节点–左子树–右子树 中序: 左子树–根节点–右子树 每一次递归的结束条件就是前序序列是否为空或者长度为1. 代码123456789101112131415161718192021222324252627282930313233343536373839/** * @Auther: zy * @Date: 2020/8/13 17:05 * @Description: 重建二叉树(前序和中序数组) * * * 前序遍历序列&#123;1,2,4,7,3,5,6,8&#125; 和 中序遍历序列&#123;4,7,2,1,5,3,8,6&#125; * */public class ReConstructBinaryTreeDemo &#123; public TreeNode reConstructBinaryTree(int[] pre,int[] in)&#123; // 判断当前序遍历的数列为空时 if(pre.length == 0) return null; //获取前序遍历的第一个数(因为前序遍历的第一个数一定是根节点的值) int rootVal = pre[0]; //如果数组长度为1,则只存在根节点直接返回 if(pre.length == 1) return new TreeNode(rootVal); TreeNode root = new TreeNode(rootVal); //获取根节点在中序遍历中的下标 int rootIndex = 0; for(int i = 0; i &lt; in.length; i++)&#123; if(rootVal == in[i])&#123; rootIndex = i; break; &#125; &#125; //只需要将确定的左右子树安到root上即可.递归要注意出口 //这里注意Arrays.copyOfRange(int[],start,end)是[)的区间 root.left = reConstructBinaryTree(Arrays.copyOfRange(pre,1,rootIndex+1),Arrays.copyOfRange(in,0,rootIndex)); root.right = reConstructBinaryTree(Arrays.copyOfRange(pre,rootIndex+1, pre.length),Arrays.copyOfRange(in,rootIndex+1,in.length)); return root; &#125;&#125;]]></content>
      <categories>
        <category>study</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>BinaryTree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手撕快速排序(QuickSort)]]></title>
    <url>%2F2020%2F08%2F13%2F%E6%89%8B%E6%92%95%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F-QuickSort%2F</url>
    <content type="text"><![CDATA[基本思想快速排序其实是对冒泡排序的一种改进.通过每一趟排序将要排序的数放在合适的位置,并且将要排序的数据分为两部分(其中一部分均比该数小,另一部分均比该数大).然后再不断的对两部分数据进行排序 代码直接上代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/** * @Auther: zy * @Date: 2020/8/13 14:42 * @Description: 快速排序 * 时间复杂度O(nlogn) */public class QuickSort &#123; private int[] array; public QuickSort(int[] array)&#123; this.array = array; &#125; public void sort()&#123; quickSort(array,0,array.length-1); &#125; public void quickSort(int[] array,int start,int end)&#123; if(start &lt; end)&#123; int index = array[start]; int i = start; int j = end; //当i == j时退出循环 while (i &lt; j)&#123; //找到第一个下标j的数小于index,否则j-- while(array[j] &gt;= index &amp;&amp; j &gt; i)&#123; j--; &#125; if(i &lt; j)&#123; array[i] = array[j]; i++; &#125; //找到第一个下标为i大于index的数,否则i++ while (array[i] &lt;= index &amp;&amp; i &lt; j)&#123; i++; &#125; if(i &lt; j)&#123; array[j] = array[i]; j--; &#125; array[i] = index; &#125; //将每一次排序后从已排好数的位置分为两部分再次排序 //此时i的位置就是已排序数的位置(即分为start - i-1 和 i+1 - end)两部分 quickSort(array,start,i-1); quickSort(array,i+1,end); &#125; &#125; public void print()&#123; for (int i = 0; i &lt; array.length - 1; i++) &#123; System.out.print(array[i]); &#125; System.out.println(); &#125; public static void main(String[] args) &#123; int[] num = &#123;5,9,1,9,5,3,7,6,1&#125;; QuickSort quickSort = new QuickSort(num); quickSort.sort(); quickSort.print(); &#125;&#125;]]></content>
      <categories>
        <category>study</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java三种代理模式]]></title>
    <url>%2F2020%2F08%2F13%2FJava%E4%B8%89%E7%A7%8D%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[代理模式代理(Proxy) 是一种设计模式,提供了对目标对象另外的访问方式;即通过代理对象访问目标对象. 这样做的好处: 在不改变目标对象的基础上,可以对目标对象进行功能的拓展 静态代理静态代理在使用时,需要定义接口或者父类,被代理对象与代理对象一起实现相同的接口或者是继承相同父类. 案例定义一个接口ISing,在其中定义一个方法sing() 12345678/** * @Auther: zy * @Date: 2020/8/13 11:07 * @Description: 接口 */public interface ISing &#123; void sing();&#125; 定义一个目标对象Singer实现该接口并且重写其sing()方法 1234567891011/** * @Auther: zy * @Date: 2020/8/13 11:07 * @Description: 接口实现,目标对象 */public class Singer implements ISing &#123; @Override public void sing() &#123; System.out.println("唱歌"); &#125;&#125; 这里再定义一个代理对象StaticProxy同时也实现ISing接口并重写sing()方法(加上新功能),然后通过调用代理对象来对目标对象进行调用 123456789101112131415161718192021/** * @Auther: zy * @Date: 2020/8/13 11:11 * @Description: 代理对象,静态代理 */public class StaticProxy implements ISing&#123; //保存目标对象 private ISing target; public StaticProxy(ISing target)&#123; this.target = target; &#125; @Override public void sing() &#123; System.out.println("唱歌前"); target.sing(); System.out.println("唱歌后"); &#125;&#125; 定义测试类Test 1234567891011121314151617/** * @Auther: zy * @Date: 2020/8/13 11:12 * @Description: 测试类 */public class Test &#123; public static void main(String[] args) &#123; // 目标对象 Singer singer = new Singer(); //代理对象,把目标对象传给代理对象,建立代理关系 StaticProxy staticProxy = new StaticProxy(singer); staticProxy.sing(); //执行代理方法 &#125;&#125; 总结 优点: 可以做到在不修改目标对象的功能前提下,对目标功能扩展. 缺点: 因为代理对象需要与目标对象实现一样的接口,所以会有很多代理类,类太多.同时,一旦接口增加方法,目标对象与代理对象都要维护 动态代理(JDK代理) 动态代理相比静态代理,前者的代理对象可以不实现接口 代理对象的生成,是利用JDK的API,动态的在内存中构建代理对象(需要我们指定创建代理对象/目标对象实现的接口的类型) 案例接口的定义和目标对象实现接口 与 静态代理一样不需要改变 12345678/** * @Auther: zy * @Date: 2020/8/13 11:36 * @Description: 接口 */public interface ISing &#123; void sing();&#125; 1234567891011/** * @Auther: zy * @Date: 2020/8/13 11:37 * @Description: 目标对象 实现接口 */public class Singer implements ISing &#123; @Override public void sing() &#123; System.out.println("唱歌"); &#125;&#125; 因为Java底层封装实现的细节. 直接调用Proxy类的静态方法newProxyInstance,该方法会返回代理对象 static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces,InvocationHandler h ) 接收的三个参数依次为: ClassLoader loader：指定当前目标对象使用类加载器，写法固定 Class&lt;?&gt;[] interfaces：目标对象实现的接口的类型，写法固定 InvocationHandler h：事件处理接口，需传入一个实现类，一般直接使用匿名内部类 定义测试类Test 1234567891011121314151617181920212223242526/** * @Auther: zy * @Date: 2020/8/13 11:38 * @Description: 测试类(动态代理jdk) */public class Test &#123; public static void main(String[] args) &#123; //目标对象 Singer target = new Singer(); ISing proxy = (ISing) Proxy.newProxyInstance( target.getClass().getClassLoader(), target.getClass().getInterfaces(), new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println("向观众问好"); // 执行目标对象方法 Object returnValue = method.invoke(target,args); System.out.println("谢谢大家"); return returnValue; &#125; &#125;); proxy.sing(); &#125;&#125; 总结 优点: 由于Java封装了newProxyInstance这个方法的实现细节,我们使用起来会非常的方便 缺点: 可以看出静态代理和JDK代理有一个共同的缺点，就是目标对象必须实现一个或多个接口，如何没有接口实现，则可以使用Cglib代理 Cglib代理(子类代理)前提条件 需要引入cglib的jar文件，由于Spring的核心包中已经包括了Cglib功能，所以也可以直接引入spring核心包 目标类不能为final 目标对象的方法如果为final/static，那么就不会被拦截，即不会执行目标对象额外的业务方法 案例目标对象(不需要实现接口) 1234567891011/** * @Auther: zy * @Date: 2020/8/13 12:15 * @Description: 目标对象(不需要实现接口 ) */public class Singer &#123; public void sing()&#123; System.out.println("唱歌"); &#125;&#125; Cglib代理工厂 12345678910111213141516171819202122232425262728293031323334/** * @Auther: zy * @Date: 2020/8/13 12:16 * @Description: Cglib子类代理工厂 */public class CglibProxy implements MethodInterceptor &#123; // 维护目标对象 private Object target; public CglibProxy(Object target)&#123; this.target = target; &#125; // 给目标对象创建一个代理对象 public Object getProxyInstance()&#123; // 1.工具类 Enhancer en = new Enhancer(); // 2.设置父类 en.setSuperclass(target.getClass()); // 3.设置回调函数 en.setCallback(this); // 4.创建子类 return en.create(); &#125; @Override public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123; System.out.println("向观众问好"); Object returnValue = method.invoke(target,objects); System.out.println("谢谢大家"); return returnValue; &#125;&#125; 测试类 123456789101112131415/** * @Auther: zy * @Date: 2020/8/13 12:23 * @Description: 代理类 */public class Test &#123; public static void main(String[] args) &#123; // 目标对象 Singer target = new Singer(); // 获取代理对象 Singer proxy = (Singer) new CglibProxy(target).getProxyInstance(); // 执行代理对象的方法 proxy.sing(); &#125;&#125; 总结三种代理模式各有优缺点和相应的适用范围 例如: 静态代理和动态代理(JDK代理)都需要实现接口,但是动态代理中由于Java封装了实现的细节,所以我们只需要调用Proxy类中的newProxyInstance静态方法即可,而静态代理是需要我们手动实现代理类的细节 动态代理与Cglib代理的区别,主要看目标对象是否实现了接口 在Spring框架中选择的代理模式(在Spring的AOP编程中): 如果加入容器的目标对象有实现接口，用JDK代理 如果目标对象没有实现接口，用Cglib代理]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Proxy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java学习系列之多线程]]></title>
    <url>%2F2020%2F08%2F12%2FJava%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[进程和线程进程 是资源(CPU,内存)分配的基本单位,是程序执行的一个实例,程序运行时就会创建一个实例,并为它们分配资源,然后把进程放入进程就绪队列中,进程调度器为其分配CPU时间,程序就会执行. image-20200812091927092 线程 是程序最小的执行单位,它是一个进程的执行流,是CPU调度和分配的基本单位,一个进程可以由多个线程组成,线程间共享进程的所有资源,每个线程有自己的堆栈和局部变量. 线程由CPU独立调度运行 在多CPU环境下就允许多个线程同时运行,同样多线程也可以实现并发操作,每个请求分配一个线程来处理. 区别 进程是资源分配的最小单位，线程是程序执行的最小单位 进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多 线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式（IPC)进行。不过如何处理好同步与互斥是编写多线程程序的难点 但是多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间 Threads help with both problems. Threads are sometimes called lightweight processes since a thread is “lighter weight” than a process. That is, thread creation can be 10–100 times faster than process creation. All threads within a process share the same global memory. This makes the sharing of information easy between the threads, but along with this simplicity comes the problem ​ ——–《Unix网络编程》 多线程多线程目的就是为了更好的利用CPU资源. 先搞清楚一些概念: 多线程: 指一个进程运行时产生了不止一个线程 并行并发: 并行: 多个CPU实例或者多台机器同时执行一段处理逻辑,真正的同时 并发: 通过CPU调度算法,让用户们看上去同时执行,实际上从CPU操作层面上不是真正的同时 线程安全: 指在并发的情况之下，该代码经过多线程使用，线程的调度顺序不影响任何结果 同步: Java中的同步指的是通过人为的控制和调度，保证共享资源的多线程访问成为线程安全，来保证结果的准确 线程安全的优先级大于性能 线程的状态线程的状态 线程的状态转换 线程在Running状态下可能会遇到阻塞(Blocked)情况 1. 线程调用john()或者sleep()方法后变成了阻塞状态(Blocked),当sleep()时间结束或者被打断,john()中断,IO完成都会使其从阻塞状态变为Runnable 2. 线程调用wait(),与此同时释放同步锁,使该线程处于等待池中(wait blocked pool),直到notify()或者notifyAll(), 线程会恢复锁同时被唤醒被放到锁定池(lock blocked pool )，释放同步锁使线程回到可运行状态(Runnable) 3. 对Running状态的线程加同步锁(Synchronized)使其进入(lock blocked pool),同步锁被释放进入可运行状态(Runnable)每个对象的方法(机制)synchronized, wait, notify 是任何对象都具有的同步工具 Monitor: Java中的每个对象都有一个监视器，来监测并发代码的重入. 在非多线程编码时该监视器不发挥作用，反之如果在synchronized 范围内，监视器发挥作用 wait/notify必须存在于synchronized块中 并且，这三个关键字针对的是同一个监视器(某对象的监视器) 这意味着wait之后，其他线程可以进入同步块执行 (如果当wait/notify方法没有在synchronized块中调用的话以及在该synchroized中调用其他对象的wait/notify都会因为当某代码并不持有监视器的使用权而抛出java.lang.IllegalMonitorStateException) Synchronized的用法: 代码块: 在多线程环境下，synchronized块中的方法获取了lock实例的monitor，如果实例相同，那么只有一个线程能执行该块内容 123456789101112131415/** * @Auther: zy * @Date: 2020/8/12 10:29 * @Description: */public class ThreadDemo02 implements Runnable&#123; Object lock; @Override public void run() &#123; synchronized (lock)&#123; //do somesthing &#125; &#125;&#125; 方法: 相当于上面代码中用lock来锁定的效果，实际获取的是ThreadDemo02类的monitor 更进一步，如果修饰的是static方法，则锁定该类所有实例 12345public class Thread1 implements Runnable &#123; public synchronized void run() &#123; //do something &#125;&#125; 经典实例: 生产者消费者问题 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * 生产者生产出来的产品交给店员 */ public synchronized void produce() &#123; if(this.product &gt;= MAX_PRODUCT) &#123; try &#123; wait(); System.out.println("产品已满,请稍候再生产"); &#125; catch(InterruptedException e) &#123; e.printStackTrace(); &#125; return; &#125; this.product++; System.out.println("生产者生产第" + this.product + "个产品."); notifyAll(); //通知等待区的消费者可以取出产品了 &#125; /** * 消费者从店员取产品 */ public synchronized void consume() &#123; if(this.product &lt;= MIN_PRODUCT) &#123; try &#123; wait(); System.out.println("缺货,稍候再取"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return; &#125; System.out.println("消费者取走了第" + this.product + "个产品."); this.product--; notifyAll(); //通知等待去的生产者可以生产产品了 &#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手撕归并排序(MERGE-SORT)]]></title>
    <url>%2F2020%2F08%2F05%2F%E6%89%8B%E6%92%95%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F-MERGE-SORT%2F</url>
    <content type="text"><![CDATA[基本思想归并排序(MERGE-SORT) 该算法运用到 分治思想 所谓分治: 分 就是将问题分成一系列小的问题然后递归求解 治 就是将各阶段的答案进行修补在一起 分(divide)分阶段可以理解为就是递归拆分子序列的过程，递归深度为log2n. 我们对于一个数组例如{3,1,4,5,2,7,8,1},我们先进行分操作:将长度为n的数组分成两个长度为n/2的数组(假设start和end分别代表各数组的第一个元素和最后一个元素) 我们在不断递归进行拆分数组的时候,终止条件就是当(start &gt;= end)—反过来也就是当(start &lt; end)执行递归拆分 代码123456789101112131415public static void sort(int[] arr)&#123; int[] temp = new int[arr.length]; sort(arr,0,arr.length-1,temp);&#125;public static void sort(int[] arr,int start,int end,int[] temp)&#123; if(start &lt; end)&#123; int mid = (start + end) &gt;&gt; 1; sort(arr,start,mid,temp); sort(arr,mid+1,end,temp); merge(arr,start,mid,end,temp); &#125;&#125; 合(merge)我们在进行merge操作的时候,是对不同的部分进行合并排序,我们需要利用一个额外temp数组将两个不同部分进行比较依次放入temp数组中.例如: 在我们拆分到不可再分的时候(同样是对于一个数组例如{3,1,4,5,2,7,8,1}) {3,1},我们需要把它们进行比较然后放入temp数组中,然后将临时数组temp放回原始数组arr中去 同样的对于{4,5}也是上述同样的操作. 这两步操作完后arr数组中已经对{3,1,4,5}已经排好序.剩下的就是对原始数组的右半部分进行分合排序 代码123456789101112131415161718192021222324public static void merge(int[] arr,int start,int mid,int end,int[] temp)&#123; int i = start; int j = mid + 1; int cur = 0; while(i &lt;= mid &amp;&amp; j &lt;= end)&#123; if(arr[i] &lt;= arr[j])&#123; temp[cur++] = arr[i++]; &#125; else &#123; temp[cur++] = arr[j++]; &#125; &#125; while (i &lt;= mid)&#123; //将左边剩余元素填充进temp中 temp[cur++] = arr[i++]; &#125; while(j &lt;= end)&#123; //将右序列剩余元素填充进temp中 temp[cur++] = arr[j++]; &#125; cur = 0; while (start &lt;= end)&#123; //将temp中的元素全部拷贝到原数组中 arr[start++] = temp[cur++]; &#125; &#125; 归并排序借鉴一下网上一张图来直观说明大致流程 完整代码: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * @Auther: zy * @Date: 2020/8/5 14:21 * @Description: */public class MergeSort &#123; public static void sort(int[] arr)&#123; int[] temp = new int[arr.length]; sort(arr,0,arr.length-1,temp); //在排序前，先建好一个长度等于原数组长度的临时数组，避免递归中频繁开辟空间 &#125; public static void sort(int[] arr,int start,int end,int[] temp)&#123; if(start &lt; end)&#123; int mid = (start + end) &gt;&gt; 1; sort(arr,start,mid,temp); //左边归并排序，使得左子序列有序 sort(arr,mid+1,end,temp); //右边归并排序，使得右子序列有序 merge(arr,start,mid,end,temp); //将两个有序子数组合并操作 &#125; &#125; public static void merge(int[] arr,int start,int mid,int end,int[] temp)&#123; int i = start; int j = mid + 1; int cur = 0; while(i &lt;= mid &amp;&amp; j &lt;= end)&#123; if(arr[i] &lt;= arr[j])&#123; temp[cur++] = arr[i++]; &#125; else &#123; temp[cur++] = arr[j++]; &#125; &#125; while (i &lt;= mid)&#123; //将左边剩余元素填充进temp中 temp[cur++] = arr[i++]; &#125; while(j &lt;= end)&#123; //将右序列剩余元素填充进temp中 temp[cur++] = arr[j++]; &#125; cur = 0; while (start &lt;= end)&#123; //将temp中的元素全部拷贝到原数组中 arr[start++] = temp[cur++]; &#125; &#125; public static void main(String [] args)&#123; int[] arr = &#123;3,2,1,5,2,31,45,6,2312&#125;; sort(arr); System.out.println(Arrays.toString(arr)); &#125;&#125; 结果: 123[1, 2, 2, 3, 5, 6, 31, 45, 2312]Process finished with exit code 0]]></content>
      <categories>
        <category>study</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 240. FindNumberIn2DArray(Easy)(剑指Offer 04)]]></title>
    <url>%2F2020%2F08%2F03%2FLeetCode-240-FindNumberIn2DArray-%E5%89%91%E6%8C%87Offer-04%2F</url>
    <content type="text"><![CDATA[题目:在一个 n * m的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 示例现有矩阵 matrix 如下： 1234567[ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30]] 给定 target = 5，返回 true。 给定 target = 20，返回 false。 限制0 &lt;= n &lt;= 1000 0 &lt;= m &lt;= 1000 解题思路我们要从一个二维数组的里面找是否存在某一特定值target, 因为该二维数组存在一个规律: 每一行从左到右递增的顺序排序 每一列从上到下递增的顺序排列 从这个规律中我们可以得出几个结论: 左上角的值是每一行最小同时也是每一列最小的 右上角的值是每一行最大的同时是每一列最小的 左下角的值是每一行最小同时也是每一列最大的 右下角的值是每一行最大的同时是每一列最大的 我们比较值可以从这四个角度去当作入口进入数组进行比较.但是其中左上和右下的值都是同为最小或者最大,导致我们进行判定matrix[i][j]与target大小关系时. 例如: matrix[i][j] &gt; target我们就可以判断该target 不在该二维数组中 而当matrix[i][j] &lt; target时 就剩下右边和下方以及重叠区域需要进行判断会很复杂 所以我们选择右上或者左下的值当作入口进行判断.当matrix[i][j] &gt; target 时,我们就可以排除当前列(因为该值为当前列的最小值). 当matrix[i][j] &lt; target时,我们就可以排除当前行(因为该值为当前值的最大值) 这样一来我们每一次进行比较就可以排除一行或者一列直到找到是否存在. 代码12345678910111213141516class Solution &#123; public boolean findNumberIn2DArray(int[][] matrix, int target) &#123; if(matrix.length == 0 || matrix[0].length == 0) return false; int m = matrix.length; int n = matrix[0].length; for(int i = 0; i &lt; m; i++)&#123; int[] col = matrix[i]; for(int j = n-1; j &gt;= 0; j--)&#123; if(matrix[i][j] == target) return true; else if(matrix[i][j] &gt; target) n--; else break; &#125; &#125; return false; &#125;&#125;]]></content>
      <categories>
        <category>study</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 120. MinimunTotal(Medium)]]></title>
    <url>%2F2020%2F07%2F26%2FLeetCode-120-MinimunTotal%2F</url>
    <content type="text"><![CDATA[题目给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。 相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。 示例例如，给定三角形： 123456[ [2], [3,4], [6,5,7], [4,1,8,3]] 自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11） 解题思路DP(自底向上) DP数组,我们需要开辟n+1xm+1的大小.此时的m和n分别为给定List的大小即: 123int m = triangle.size(); int n = triangle.get(m-1).size(); int[][] dp = new int[n+1][m+1]; 然后并初始化最下层为0 也就是dp[n][i] (i : 0-m) 即: 1234//初始化第n层均为0 for(int i = 0;i &lt;= n;i++)&#123; dp[m][i] = 0; &#125; 因为我们是从顶向上进行求解的.我们在得出dp状态转换方程为: 1dp[i][j] = min(dp[i+1][j],dp[i+1][j+1]) + nums[i][j] dp[i][j] 表示从点 (i, j)(i,j) 到底边的最小路径和 这种解法相比自顶向下的递归有一个好处就是不需要在最后的时候查找最小值而是直接返回dp[0][0]就可以了 代码DP(自底向上) 123456789101112131415161718class Solution &#123; public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) &#123; if(triangle == null || triangle.size() == 0) return 0; int m = triangle.size(); int n = triangle.get(m-1).size(); int[][] dp = new int[n+1][m+1]; //初始化第m层均为0 for(int i = 0;i &lt;= n;i++)&#123; dp[m][i] = 0; &#125; for(int i = m-1;i &gt;= 0;i--)&#123; for(int j = 0;j &lt;= i;j++)&#123; dp[i][j] = Math.min(dp[i+1][j],dp[i+1][j+1]) + triangle.get(i).get(j); &#125; &#125; return dp[0][0]; &#125;&#125; 总结目前只把自己懂的一种解法写出来了,还在研究其他大佬的解法.在后面会更新.]]></content>
      <categories>
        <category>study</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 70. ClimbStairs(Easy)]]></title>
    <url>%2F2020%2F07%2F25%2FLeetCode-70-ClimbStairs%2F</url>
    <content type="text"><![CDATA[题目假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定 n 是一个正整数。 在线练习LeetCode: https://leetcode-cn.com/problems/climbing-stairs/ 示例示例1: 12345输入： 2输出： 2解释： 有两种方法可以爬到楼顶。1. 1 阶 + 1 阶2. 2 阶 示例2: 123456输入： 3输出： 3解释： 有三种方法可以爬到楼顶。1. 1 阶 + 1 阶 + 1 阶2. 1 阶 + 2 阶3. 2 阶 + 1 阶 解题思路递归法 很明显当n&lt;=2的时候即爬到第一层第二层有几种方法均为n种,所以我们在最开始进行判断 1if(n &lt;= 2) return n; 如果n&gt;2的话,在爬到n层楼梯需要的方法数是爬到n-1层的方法数+爬到n-2层需要的方法数.即: 1int res = climbStairs(n-1)+climbStairs(n-2); 但是这道题用递归是TLE了.所以我们需要进行优化. 递归法 + 备忘录算法 因为我们在递归的时候总是会重复计算值,试想当这个n很大的时候重复计算的次数会不断增加.所以我们在进行递归的时候需要进行保存计算过的值(可以用HashMap,HashSet或者数组等等). 这里我们开一个数组,数组的长度为n+1,在每次递归的时候对num[n]的值进行判断 1if(nums[n] &gt; 0) 如果nums[n]的值大于0则返回nums[n]否则进行递归求值赋给nums[n]然后再返回nums[n] 动态规划 动态规划就是将一个问题划分成多个子问题.爬第n阶楼梯的方法数量等于 2 部分之和: 爬上 n-1 阶楼梯的方法数量.因为再爬1阶就能到第n阶 爬上 n-2 阶楼梯的方法数量,因为再爬2阶就能到第n阶公式nums[n] = nums[n-1] + nums[n-2] (n &gt; 2) 代码递归法 123456class Solution &#123; public int climbStairs(int n) &#123; if(n &lt;= 2) return n; return climbStairs(n-1)+climbStairs(n-2); &#125;&#125; 递归法 + 备忘录算法 12345678910111213141516class Solution &#123; public int climbStairs(int n) &#123; int[] nums = new int[n+1]; return calculate(n,nums); &#125; public int calculate(int n,int[] nums)&#123; if(n &lt;= 2) return n; if(nums[n] &gt; 0)&#123; return nums[n]; &#125; nums[n] = calculate(n-1,nums) + calculate(n-2,nums); return nums[n]; &#125;&#125; 动态规划 12345678910111213141516class Solution &#123; public int climbStairs(int n) &#123; int[] nums = new int[n+1]; if(n &lt;= 2) return n; return calculate(n,nums); &#125; public int calculate(int n,int[] nums)&#123; nums[1] = 1; nums[2] = 2; for(int i = 3;i &lt; nums.length;i++)&#123; nums[i] = nums[i-1] + nums[i-2]; &#125; return nums[n]; &#125;&#125; 总结这道题在LeetCode上是属于Easy难度的,也是练习DP的第一道题]]></content>
      <categories>
        <category>study</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java学习系列之容器]]></title>
    <url>%2F2020%2F07%2F25%2FJava%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B9%8B%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[一.概览容器主要包括Collection和Map两种,Collection存储着对象集合而Map存储着键值对(两个对象)的映射表 1.Set TreeSet:基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN) HashSet:基于哈希表实现,支持快速查找,但不支持有序性操作.并且失去了元素的插入顺序信息,也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的 LinkedHashSet:具有 HashSet 的查找效率,并且内部使用双向链表维护元素的插入顺序 2.List ArrayList: 基于动态数组实现,支持随机访问 Vector: 和ArrayList类似,是线程安全的 LinkedList: 基于双向链表实现的,只能顺序访问,但是可以快速地在链表中间插入和删除元素.LinkedList 还可以用作栈、队列和双向队列. 3.Queue LinkedList：可以用它来实现双向队列. PriorityQueue：基于堆结构实现，可以用它来实现优先队列. 4.Map TreeMap：基于红黑树实现. HashMap：基于哈希表实现. HashTable：和 HashMap 类似,但它是线程安全的,这意味着同一时刻多个线程同时写入 HashTable 不会导致数据不一致.它是遗留类,不应该去使用它,而是使用 ConcurrentHashMap 来支持线程安全，ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。 LinkedHashMap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序. 二.源码分析以下源码分析基于 JDK 1.8 ArrayList1.概览12345678910111213141516171819202122232425262728293031public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true;&#125;private void ensureCapacityInternal(int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity);&#125;private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125;private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);&#125; 2.扩容添加元素时使用 ensureCapacityInternal() 方法来保证容量足够,如果不够时,需要使用 grow() 方法进行扩容,新容量的大小为 oldCapacity + (oldCapacity &gt;&gt; 1) 也就是旧容量的 1.5 倍. 分析: 把数组的长度赋给oldCapacity 1int oldCapacity = elementData.length; 新的数组容量=老的数组长度的1.5倍.oldCapacity &gt;&gt; 1 相当于除以2 1int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); (这里补一下位运算的知识) 位运算 如果新的数组容量newCapacity小于传入的参数要求的最小容量minCapacity,那么新的数组容量以传入的容量参数为准12if (newCapacity - minCapacity &lt; 0)newCapacity = minCapacity; 4.如果新的数组容量newCapacity大于数组能容纳的最大元素个数 MAX_ARRAY_SIZE (2^{31}-1-8)那么再判断传入的参数minCapacity是否大于MAX_ARRAY_SIZE,如果minCapacity大于MAX_ARRAY_SIZE,那么newCapacity等于Integer.MAX_VALUE,否者newCapacity等于MAX_ARRAY_SIZE 12if (newCapacity - MAX_ARRAY_SIZE &gt; 0)newCapacity = hugeCapacity(minCapacity); 3.删除需要调用 System.arraycopy() 将 index+1 后面的元素都复制到 index 位置上，该操作的时间复杂度为 O(N)，可以看到 ArrayList 删除元素的代价是非常高的 12345678910public E remove(int index) &#123; rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue;&#125; 4.序列化ArrayList 基于数组实现,并且具有动态扩容特性,因此保存元素的数组不一定都会被使用,那么就没必要全部进行序列化 保存元素的数组 elementData 使用 transient 修饰,该关键字声明数组默认不会被序列化 1transient Object[] elementData; // non-private to simplify nested class access ArrayList 实现了writeObject() 和 readObject() 来控制只序列化数组中有元素填充那部分内容 123456789101112131415161718192021private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; elementData = EMPTY_ELEMENTDATA; // Read in size, and any hidden stuff s.defaultReadObject(); // Read in capacity s.readInt(); // ignored if (size &gt; 0) &#123; // be like clone(), allocate array based upon size not capacity ensureCapacityInternal(size); Object[] a = elementData; // Read in all elements in the proper order. for (int i=0; i&lt;size; i++) &#123; a[i] = s.readObject(); &#125; &#125;&#125; 123456789101112131415161718private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException&#123; // Write out element count, and any hidden stuff int expectedModCount = modCount; s.defaultWriteObject(); // Write out size as capacity for behavioural compatibility with clone() s.writeInt(size); // Write out all elements in the proper order. for (int i=0; i&lt;size; i++) &#123; s.writeObject(elementData[i]); &#125; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125;&#125; 序列化时需要使用 ObjectOutputStream 的 writeObject() 将对象转换为字节流并输出.而 writeObject() 方法在传入的对象存在 writeObject() 的时候会去反射调用该对象的 writeObject() 来实现序列化.反序列化使用的是 ObjectInputStream 的 readObject() 方法，原理类似. 后续待更新]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Container</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java学习系列之Obejct通用方法]]></title>
    <url>%2F2020%2F07%2F24%2FJava%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B9%8BObejct%E9%80%9A%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[概览Object通用方法有: 123456789101112131415161718192021public native int hashCode()public boolean equals(Object obj)protected native Object clone() throws CloneNotSupportedExceptionpublic String toString()public final native Class&lt;?&gt; getClass()protected void finalize() throws Throwable &#123;&#125;public final native void notify()public final native void notifyAll()public final native void wait(long timeout) throws InterruptedExceptionpublic final void wait(long timeout, int nanos) throws InterruptedExceptionpublic final void wait() throws InterruptedException equals() 等价与相等1234Integer x = new Integer(1);Integer y = new Integer(1);System.out.println(x.equals(y)); // trueSystem.out.println(x == y); // false 对于基本类型,由于没有equals()方法,就使用==来进行判断值是否相等 对于引用类型,==是判断两个变量是否引用同一个对象,而equals()是判断两个变量的值是否相等 hashCode()hashCode() 返回哈希值，而 equals() 是用来判断两个对象是否等价。等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价，这是因为计算哈希值具有随机性，两个值不同的对象可能计算出相同的哈希值。 在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，保证等价的两个对象哈希值也相等 HashSet 和 HashMap 等集合类使用了 hashCode() 方法来计算对象应该存储的位置，因此要将对象添加到这些集合类中，需要让对应的类实现 hashCode() 方法 toString()默认返回 ToStringExample@4554617c 这种形式，其中 @ 后面的数值为散列码的无符号十六进制表示 clone()1.cloneableclone() 是 Object 的 protected 方法，它不是 public，一个类不显式去重写 clone()，其它类就不能直接去调用该类实例的 clone() 方法 123456789public class CloneExample &#123; private int a; private int b; @Override public CloneExample clone() throws CloneNotSupportedException &#123; return (CloneExample)super.clone(); &#125;&#125; 123456CloneExample e1 = new CloneExample();try &#123; CloneExample e2 = e1.clone();&#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace();&#125; 以上抛出了 CloneNotSupportedException，这是因为 CloneExample 没有实现 Cloneable 接口。 应该注意的是，clone() 方法并不是 Cloneable 接口的方法，而是 Object 的一个 protected 方法。Cloneable 接口只是规定，如果一个类没有实现 Cloneable 接口又调用了 clone() 方法，就会抛出 CloneNotSupportedException 2.浅拷贝拷贝对象和原始对象的引用类型引用同一个对象 对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值传递，也就是将该属性值复制一份给新的对象。因为是两份不同的数据，所以对其中一个对象的该成员变量值进行修改，不会影响另一个对象拷贝得到的数据 对于数据类型是引用数据类型的成员变量，比如说成员变量是某个数组、某个类的对象等，那么浅拷贝会进行引用传递，也就是只是将该成员变量的引用值（内存地址）复制一份给新的对象。因为实际上两个对象的该成员变量都指向同一个实例。在这种情况下，在一个对象中修改该成员变量会影响到另一个对象的该成员变量值 3.深拷贝拷贝对象和原始对象的引用类型引用不同对象 深拷贝对引用数据类型的成员变量的对象图中所有的对象都开辟了内存空间；而浅拷贝只是传递地址指向，新的对象并没有对引用数据类型创建内存空间 4.clone() 的替代方案使用 clone() 方法来拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型转换。Effective Java 书上讲到，最好不要去使用 clone()，可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>ObjectMethod</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java学习系列之关键词(final和static)]]></title>
    <url>%2F2020%2F07%2F17%2FJava%E5%85%B3%E9%94%AE%E5%AD%97-final%E5%92%8Cstatic%2F</url>
    <content type="text"><![CDATA[一. final1. 数据声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。 对于基本类型，final 使数值不变； 对于引用类型，final使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。1234final int x = 1;// x = 2; // cannot assign value to final variable &apos;x&apos;final A y = new A();y.a = 1; 2. 方法声明方法不能被子类重写。 private 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法。 3. 类声明类不允许被继承。 二. static1. 静态变量 静态变量: 又称类变量,意思是这个变量是属于类的,类所有的实例都共享静态变量，可以直接通过类名来访问它.静态变量在内存中只存在一份. 实例变量: 每创建一个实例就会产生一个实例变量.123456789101112public class A &#123; private int x; // 实例变量 private static int y; // 静态变量 public static void main(String[] args) &#123; // int x = A.x; // Non-static field &apos;x&apos; cannot be referenced from a static context A a = new A(); int x = a.x; int y = A.y; &#125;&#125; 2. 静态方法静态方法在类加载的时候就存在了，它不依赖于任何实例.所以静态方法必须有实现，也就是说它不能是抽象方法. 12345public abstract class A &#123; public static void func1()&#123; &#125; // public abstract static void func2(); // Illegal combination of modifiers: &apos;abstract&apos; and &apos;static&apos;&#125; 只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字，因此这两个关键字与具体对象关联。 Q:为什么静态方法不能调用非静态变量，非静态方法可以引用静态变量? A:理由很简单，静态方法不属于对象，是属于类的，是不需要实例化的，而非静态变量是属于对象的，需要先实例化。在一个类的静态成员中去访问其非静态成员之所以会出错是因为在类的非静态成员不存在的时候类的静态成员就已经存在了，访问一个内存中不存在的东西当然会出错. 抽象类,抽象方法(关于抽象类,抽象方法: 当父类的某些方法不确定时，可以用abstract关键字来修饰该方法[抽象方法]，用abstract来修饰该类[抽象类]. 父类是将子类所共同拥有的属性和方法进行抽取，这些属性和方法中，有的是已经明确实现了的，有的还无法确定，那么我们就可以将其定义成抽象，在后日子类进行重用，进行具体化. 12345678910111213141516// 这就是一个抽象类abstract class Animal &#123; String name; int age; // 动物会叫 public abstract void cry(); // 不确定动物怎么叫的。定义成抽象方法，来解决父类方法的不确定性。抽象方法在父类中不能实现，所以没有函数体。但在后续在继承时，要具体实现此方法。&#125;// 抽象类可以被继承// 当继承的父类是抽象类时，需要将抽象类中的所有抽象方法全部实现。class cat extends Animal &#123; // 实现父类的cry抽象方法 public void cry() &#123; System.out.println(&quot;猫叫:&quot;);&#125; 值得注意的是: 必须是抽象类才能拥有抽象方法 抽象方法在被子类继承的时候必须要实现(全部抽象方法) 抽象类不能被实例化 ) 3. 静态语句块静态语句块只在类初始化的时候运行一次 12345678910111213public class A &#123; static &#123; System.out.println(&quot;123&quot;); &#125; public static void main(String[] args) &#123; A a1 = new A(); A a2 = new A(); &#125;&#125;only print 1 time123 4. 静态内部类非静态内部类依赖于外部类的实例，也就是说需要先创建外部类实例，才能用这个实例去创建非静态内部类。而静态内部类不需要. 123456789101112131415public class OuterClass &#123; class InnerClass &#123; &#125; static class StaticInnerClass &#123; &#125; public static void main(String[] args) &#123; // InnerClass innerClass = new InnerClass(); // &apos;OuterClass.this&apos; cannot be referenced from a static context OuterClass outerClass = new OuterClass(); InnerClass innerClass = outerClass.new InnerClass(); StaticInnerClass staticInnerClass = new StaticInnerClass(); &#125;&#125; 静态内部类不能访问外部类的非静态的变量和方法 5. 初始化顺序静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序 1public static String staticField = &quot;静态变量&quot;; 123static &#123; System.out.println(&quot;静态语句块&quot;);&#125; 1public String field = &quot;实例变量&quot;; 123public InitialOrderTest() &#123; System.out.println(&quot;构造函数&quot;);&#125; 如果存在继承关系的时候,初始化顺序为: 123456父类（静态变量、静态语句块）子类（静态变量、静态语句块）父类（实例变量、普通语句块）父类（构造函数）子类（实例变量、普通语句块）子类（构造函数）]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>关键词</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 145. postorderTraversal(Hard)]]></title>
    <url>%2F2020%2F07%2F14%2FLeetCode-145-postorderTraversal%2F</url>
    <content type="text"><![CDATA[题目给定一个二叉树，返回它的 后序 遍历。 示例12345678输入: [1,null,2,3] 1 \ 2 / 3 输出: [3,2,1] 进阶:递归算法很简单，你可以通过迭代算法完成吗？ 解题思路常规思路 递归 迭代 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; // 1. Recursion // public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; // List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); // if(root == null) return res; // Recursion(root,res); // return res; // &#125; // public void Recursion(TreeNode root,List&lt;Integer&gt; res)&#123; // if(root.left != null) Recursion(root.left,res); // if(root.right != null) Recursion(root.right,res); // res.add(root.val); // &#125; // 2. Iteration public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); if(root == null) return res; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode target = null; while(root != null || !stack.isEmpty())&#123; while(root != null)&#123; stack.push(root); root = root.left; &#125; root = stack.peek(); if(root.right == null || target == root.right)&#123; root = stack.pop(); res.add(root.val); target = root; root = null; &#125;else&#123; root = root.right; &#125; &#125; return res; &#125; &#125;]]></content>
      <categories>
        <category>study</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>BinaryTree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 94. inorderTraversal(Medium)]]></title>
    <url>%2F2020%2F07%2F14%2FLeetCode-94-inorderTraversal%2F</url>
    <content type="text"><![CDATA[题目给定一个二叉树，返回它的 中序 遍历 示例12345678输入: [1,null,2,3] 1 \ 2 / 3输出: [1,3,2] 进阶:递归算法很简单，你可以通过迭代算法完成吗？ 解题思路常规思路 递归 迭代 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; // 1.Recursion public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if(root == null) return res; Recursion(root,res); return res; &#125; public void Recursion(TreeNode cur,List&lt;Integer&gt; res)&#123; if(cur.left != null) Recursion(cur.left,res); res.add(cur.val); if(cur.right != null) Recursion(cur.right,res); &#125; // 2. Iteration // public List&lt;Integer&gt; inorderTraversal(TreeNode root)&#123; // List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); // if(root == null) return res; // Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); // while(root != null || !stack.isEmpty())&#123; // if(root != null)&#123; // stack.push(root); // root = root.left; // &#125; // else&#123; // root = stack.pop(); // res.add(root.val); // root = root.right; // &#125; // &#125; // return res; // &#125;&#125;]]></content>
      <categories>
        <category>study</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>BinaryTree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 144. preorderTraversal(Medium)]]></title>
    <url>%2F2020%2F07%2F14%2FLeetCode-144-preorderTraversal%2F</url>
    <content type="text"><![CDATA[题目给定一个二叉树，返回它的 前序遍历 示例12345678输入: [1,null,2,3] 1 \ 2 / 3 输出: [1,2,3] 进阶:递归算法很简单，你可以通过迭代算法完成吗？ 解题思路基本思想 递归遍历(Recursion) 迭代遍历(Iteration) 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; // 1. Recursion // public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; // List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); // if(root == null) return res; // Recursion(root,res); // return res; // &#125; // public void Recursion(TreeNode cur,List&lt;Integer&gt; res)&#123; // res.add(cur.val); // if(cur.left != null) Recursion(cur.left,res); // if(cur.right != null) Recursion(cur.right,res); // &#125; // 2. Iteration public List&lt;Integer&gt; preorderTraversal(TreeNode root)&#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if(root == null) return res; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); while(root != null || !stack.isEmpty())&#123; if(root != null)&#123; res.add(root.val); stack.push(root); root = root.left; &#125;else&#123; root = stack.pop(); root = root.right; &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>study</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>BinaryTree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 206. ReverseList (Medium)]]></title>
    <url>%2F2020%2F07%2F14%2FLeetCode-206-ReverseList%2F</url>
    <content type="text"><![CDATA[题目反转一个单链表。 示例示例: 12输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 解题思路迭代法 + 双指针 在循环中需要做的事是要将当前节点指向前一个节点,所以就需要定义两个指针cur pre分别表示当前节点和前继节点.与此同时我们还需要在循环中用一个next来保存cur的后继节点避免出现节点丢失 Time complexity O(n)Space complexity O(1) 递归法 递归反转链表相比迭代是有一定的难度的我们需要明确这个函数的作用是什么:参数为头指针,反转链表后返回翻转后的链表 最难理解的是比如:4和5需要反转, 4-&gt;5 此时的cur是4,需要将cur.next.next = cur 将5的next指向4 图下是我在LeetCode讨论区找到一个gif方便理解: Time complexity O(n)Space complexity O(n) 代码迭代法 + 双指针 12345678910111213class Solution &#123; public static ListNode reverseListIterate(ListNode head) &#123; ListNode cur = head; ListNode pre = null; while(cur != null)&#123; ListNode next = cur.next; cur.next = pre; pre = cur; cur = next; &#125; return pre; &#125;&#125; 递归法 123456789class Solution &#123; public static ListNode reverseListRecursion(ListNode head)&#123; if(head == null || head.next == null) return head; ListNode temp = reverseListRecursion(head.next); head.next.next = head; head.next = null; return temp; &#125;&#125; 总结反转链表这个题最主要的还是递归方法的难以理解, 这也是递归经典题.在以后还是需要多加练习多总结才能帮助理解. 后面还要反转链表前n项 以及 反转链表部分项 等类似的题就更新到下一篇文章]]></content>
      <categories>
        <category>study</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 26. RemoveDuplicates (Easy)]]></title>
    <url>%2F2020%2F06%2F30%2FLeetCode_26_%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[题目给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。 示例示例一: 12345给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。 示例二: 12345给定 nums = [0,0,1,1,1,2,2,3,3,4],函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。你不需要考虑数组中超出新长度后面的元素。 解题思路双指针法定义慢指针i初始化为0 , 快指针j初始化为1.每一次遍历的时候,判断nums[i]与nums[j]是否相等,如果相等则j++.若不等则先i++然后将nums[j]赋值给nums[i] Time complexity O(n)Space complexity O(1) 代码1234567891011class Solution &#123; public int removeDuplicates(int[] nums) &#123; int i = 0; for(int j = 1;j &lt; nums.length;j++)&#123; if(nums[i] != nums[j])&#123; nums[++i] = nums[j]; &#125; &#125; return i+1; &#125;&#125;]]></content>
      <categories>
        <category>study</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 2. Add Two Numbers (Medium)]]></title>
    <url>%2F2020%2F06%2F29%2FLeetCode_2_%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0%2F</url>
    <content type="text"><![CDATA[题目给出两个非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照逆序的方式存储的，并且它们的每个节点只能存储一位数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0开头。 示例123输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 解题思路因为我们之后需要输出的是头节点,所以这里创建了虚拟头节点res用来最后输出,和当前节点cur用来进行两数相加操作 定义carry表示相加是否有进位,初始为0 while,判断的条件是两个链表的-&gt;next指针域是否为空 在循环体中,首先用了一个三元运算符 如果l1,l2不为空则将各自的val赋值给n1 n2,否则赋值0; 同时要判断是否有进位 在循环体结束后,判断最后一位是否有进位,如果有则在链表的最后加上值为1的结点. Time complexity O(max(n,m))Space complexity O(max(n,m)) 代码12345678910111213141516171819202122232425262728/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode* res = new ListNode(-1); //定义虚拟头节点 ListNode* cur = res; int carry = 0; while(l1||l2)&#123; int n1 = l1? l1-&gt;val : 0; int n2 = l2? l2-&gt;val : 0; int sum = n1 + n2 + carry; carry = sum/10; cur-&gt;next = new ListNode(sum%10); cur = cur-&gt;next; if(l1) l1 = l1-&gt;next; if(l2) l2 = l2-&gt;next; &#125; if(carry) cur-&gt;next = new ListNode(1); //在循环结束后如果有进位,则在最前面添加一个值为1的节点 return res-&gt;next; &#125;&#125;;]]></content>
      <categories>
        <category>study</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 1. TwoSum (Easy)]]></title>
    <url>%2F2020%2F06%2F28%2FLeetCode_1_%E4%B8%A4%E6%95%B0%E5%92%8C%2F</url>
    <content type="text"><![CDATA[题目给定一个整数数组 nums和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。 示例:1234给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 解题思路解法1: 一开始我脑海里能想到的就是暴力求解: 求和为target的两个整数,那么两次for循环 先在第一个循环里找第一个数然后在第二个循环数不断进行判断两个数之和是否等于target因为这里进行了嵌套使用了两个for循环 这样虽然节省空间,但是时间复杂度:O(n²) 解法2: 随后想到用unordered_map进行一次遍历将数组里面的值与下标以key:value保存在unordered_map里面,然后再通过一次循环查看target-nums.at(i)的差值是否在hash_map里面存在,如果存在还要进行判断下标是否为i(是否已遍历),如果都满足break跳出循环,则将两个数的下标index push_back进res数组里. 这样使用到了unordered_map, unordered_map相当于HashMap。无论从查找、插入上来说，unordered_map的效率都优于hash_map，更优于map Time complexity O(n) 代码解法1: (暴力法) 12345678910111213141516171819class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; //暴力法 int leftNum = 0; vector&lt;int&gt; res; for(int i=0;i&lt;nums.size();i++)&#123; leftNum = nums.at(i); for(int j=i+1;j&lt;nums.size();j++)&#123; if(leftNum + nums.at(j) == target)&#123; res.push_back(i); res.push_back(j); break; &#125; &#125; &#125; return res; &#125;&#125;; 解法2: (unordered_map) 1234567891011121314151617181920class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; //unordered_map unordered_map &lt;int,int&gt; numsMap; vector&lt;int&gt; res; for(int i=0;i&lt;nums.size();i++)&#123; numsMap[nums.at(i)] = i; &#125; for(int i=0;i&lt;nums.size();i++)&#123; int k = target-nums.at(i); if(numsMap.count(k) &amp;&amp; numsMap[k] != i)&#123; res.push_back(i); res.push_back(numsMap[k]); break; &#125; &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>study</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 566. Reshape the Matrix (Easy)]]></title>
    <url>%2F2020%2F06%2F27%2FLeetCode_566_%E9%87%8D%E5%A1%91%E7%9F%A9%E9%98%B5%2F</url>
    <content type="text"><![CDATA[题目:在MATLAB中，有一个非常有用的函数 reshape，它可以将一个矩阵重塑为另一个大小不同的新矩阵，但保留其原始数据。 给出一个由二维数组表示的矩阵，以及两个正整数r和c，分别表示想要的重构的矩阵的行数和列数。 重构后的矩阵需要将原始矩阵的所有元素以相同的行遍历顺序填充。 如果具有给定参数的reshape操作是可行且合理的，则输出新的重塑矩阵；否则，输出原始矩阵。 解题思路:获取nums的大小分别为:nums.size()以及nums[0].size() 然后进行判断是否能够重塑另一个rc的矩阵:`nums.size() * nums[0].size() ==? rc如果不相等则返回之前的矩阵nums`. 如果相等则初始化一个矩阵res,然后通过行遍历顺序进行重新赋值 示例:123456789输入: nums = [[1,2], [3,4]]r = 1, c = 4输出: [[1,2,3,4]]解释:行遍历nums的结果是 [1,2,3,4]。新的矩阵是 1 * 4 矩阵, 用之前的元素值一行一行填充新矩阵。 12345678910输入: nums = [[1,2], [3,4]]r = 2, c = 4输出: [[1,2], [3,4]]解释:没有办法将 2 * 2 矩阵转化为 2 * 4 矩阵。 所以输出原矩阵。 说明: 给定矩阵的宽和高范围在 [1, 100]。 给定的 r 和 c 都是正数。 代码1234567891011121314151617181920212223class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; matrixReshape(vector&lt;vector&lt;int&gt;&gt;&amp; nums, int r, int c) &#123; int m = nums[0].size(); int n = nums.size(); if(m*n != r*c) return nums; int x = 0; int y = 0; vector&lt;vector&lt;int&gt;&gt; res(r,vector&lt;int&gt;(c)); for(int i=0;i&lt;r;i++)&#123; for(int j=0;j&lt;c;j++)&#123; res[i][j] = nums[x][y]; y++; if(y == m)&#123; x++; y=0; &#125; &#125; &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>study</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[283. Move Zeroes (Easy)]]></title>
    <url>%2F2020%2F06%2F26%2FLeetCode_283_%E7%A7%BB%E5%8A%A8%E9%9B%B6%2F</url>
    <content type="text"><![CDATA[题目:给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 示例:12输入: [0,1,0,3,12]输出: [1,3,12,0,0] 说明: 必须在原数组上操作，不能拷贝额外的数组。 尽量减少操作次数。 解题思路遍历nums的同时判断nums.at(i)是否为0,如果是那么就删除这个值然后在数组的末尾push_back0进去(tips:每进行删除然后push_back后不要将遍历变量i++,例如数组中0-0-1,第一项删除0后,变化后的nums为&#39;0-1-0&#39;,也就是第二次遍历后会判断为1而不是0,所以遍历变量不需要进行自增.而如果不为0,则进行i++) 代码12345678910111213141516class Solution &#123;public: void moveZeroes(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); for(int i=0;i&lt;n;)&#123; if(nums.at(i)==0)&#123; nums.erase(nums.begin()+i); nums.push_back(0); n--; &#125;else i++; &#125; for(int i=0;i&lt;nums.size();i++)&#123; cout &lt;&lt; nums.at(i) ; &#125; &#125;&#125;;]]></content>
      <categories>
        <category>study</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 724. Find Pivol Index (Easy)]]></title>
    <url>%2F2020%2F06%2F26%2FLeetCode_724_%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E5%BF%83%E7%B4%A2%E5%BC%95%2F</url>
    <content type="text"><![CDATA[题目:给定一个整数类型的数组nums，请编写一个能够返回数组 “中心索引” 的方法。 我们是这样定义数组 中心索引 的：数组中心索引的左侧所有元素相加的和等于右侧所有元素相加的和。 如果数组不存在中心索引，那么我们应该返回 -1。如果数组有多个中心索引，那么我们应该返回最靠近左边的那一个。 示例:123456输入：nums = [1, 7, 3, 6, 5, 6]输出：3解释：索引 3 (nums[3] = 6) 的左侧数之和 (1 + 7 + 3 = 11)，与右侧数之和 (5 + 6 = 11) 相等。同时, 3 也是第一个符合要求的中心索引。 12345输入：nums = [1, 2, 3]输出：-1解释：数组中不存在满足此条件的中心索引。 解题思路这里我们需要求的左边和以及右边的和进行比较,在进行遍历的时候对左边和进行求解是比较方便的.直接初始化leftSum=0,然后每次遍历之后可以+=进行累加求的leftSum. 最主要的还是通过leftSum求的rightSum(rightSum = sum(数组的和) - num.at(i) - leftSum) 每次循环先进行求的rightSum 然后与leftSum进行比较,如果相等则return 当前的次序i.直到数组遍历结束未找到左右和相等则返回-1. 代码1234567891011121314151617class Solution &#123;public: int pivotIndex(vector&lt;int&gt;&amp; nums) &#123; int sum = 0; int leftSum = 0; int rightSum = 0; for(int i=0;i&lt;nums.size();i++)&#123; sum += nums.at(i); &#125; for(int i=0;i&lt;nums.size();i++)&#123; rightSum = sum-nums.at(i)-leftSum; if(rightSum == leftSum) return i; leftSum += nums.at(i); &#125; return -1; &#125;&#125;;]]></content>
      <categories>
        <category>study</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 1470. Shuffle the Array (Easy)]]></title>
    <url>%2F2020%2F06%2F25%2FLeetCode_1470_%E9%87%8D%E6%96%B0%E6%8E%92%E5%88%97%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[题目给你一个数组 nums ，数组中有 2n 个元素，按 [x1,x2,...,xn,y1,y2,...,yn] 的格式排列。 请你将数组按 [x1,y1,x2,y2,...,xn,yn] 格式重新排列，返回重排后的数组。 示例示例 1： 123输入：nums = [2,5,1,3,4,7], n = 3输出：[2,3,5,4,1,7] 解释：由于 x1=2, x2=5, x3=1, y1=3, y2=4, y3=7 ，所以答案为 [2,3,5,4,1,7] 示例 2： 12输入：nums = [1,2,3,4,4,3,2,1], n = 4输出：[1,4,2,3,3,2,4,1] 示例 3： 12输入：nums = [1,1,2,2], n = 2输出：[1,2,1,2] 解题思路这里新建一个vector res,然后通过一次循环i-&gt;[0,n)将num[i]以及num[i+n]插入到新建的res中 (这里num[i]与num[i+n]分别代表题干表示的x1,y1)这样res中就保存了x1,y1,x2,y2等等..然后return 就完事儿了 代码1234567891011121314class Solution &#123;public: vector&lt;int&gt; shuffle(vector&lt;int&gt;&amp; nums, int n) &#123; vector&lt;int&gt; res; for(int i=0;i&lt;n;i++)&#123; res.push_back(nums[i]); res.push_back(nums[i+n]); &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>study</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 1486. XOR Operation in an Array (Easy)]]></title>
    <url>%2F2020%2F06%2F24%2FLeetCode_1486_%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97%2F</url>
    <content type="text"><![CDATA[题目:给你两个整数，n 和 start 。 数组 nums 定义为：nums[i] = start + 2*i（下标从 0 开始）且 n == nums.length 。 请返回 nums 中所有元素按位异或（XOR）后得到的结果。 示例:1234输入：n = 5, start = 0输出：8解释：数组 nums 为 [0, 2, 4, 6, 8]，其中 (0 ^ 2 ^ 4 ^ 6 ^ 8) = 8 。 &quot;^&quot; 为按位异或 XOR 运算符。 123输入：n = 4, start = 3输出：8解释：数组 nums 为 [3, 5, 7, 9]，其中 (3 ^ 5 ^ 7 ^ 9) = 8. 解题思路首先得明白按位异或(XOR)是什么: 参与运算的两个值，==如果两个相应位相同，则结果为0==，否则为1。即：0^0=0， 1^0=1， 0^1=1， 1^1=0 例如: 1235: 000001013: 000001005^3 = 00000001 -&gt; 1 我们这里只需要在一个for循环里面进行对每个数累计求异或运算 ^=即可 代码代码很简单 12345678910class Solution &#123;public: int xorOperation(int n, int start) &#123; int result = 0; for(int i=0; i&lt;n; i++)&#123; result ^= start + 2*i; &#125; return result; &#125;&#125;; 总结这道题是很简单的一道题.做这个题解的目的呢主要是记录一下 希望自己能慢慢在leetcode上刷题来提升自己去解决更复杂的问题.]]></content>
      <categories>
        <category>study</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HBase集群配置搭建]]></title>
    <url>%2F2020%2F05%2F08%2FHBase%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AE%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[1.集群分配这里搭建一个 3 节点的 HBase 集群，其中三台主机上均为 Regin Server。同时为了保证高可用，除了在 master 上部署主 Master 服务外，还在 slave1 上部署备用的 Master 服务。Master 服务由 Zookeeper 集群进行协调管理，如果主 Master 不可用，则备用 Master 会成为新的主 Master。 2.前置条件HBase 的运行需要依赖 Hadoop 和 JDK(HBase 2.0+ 对应 JDK 1.8+) 。同时为了保证高可用，这里我们不采用 HBase 内置的 Zookeeper 服务，而采用外置的 Zookeeper 集群。相关搭建步骤可以参阅 3.集群搭建3.1 下载并解压讲下载好的HBase可以通过WinScp上传到服务器上.然后进行解压: 1# tar -zxvf hbase-1.2.0-cdh5.15.2.tar.gz 3.2 配置环境变量1# vim /etc/profile 添加环境变量: 12export HBASE_HOME=usr/app/hbase-1.2.0-cdh5.15.2export PATH=$HBASE_HOME/bin:$PATH 使得配置生效: 12export HBASE_HOME=usr/app/hbase-1.2.0-cdh5.15.2export PATH=$HBASE_HOME/bin:$PATH 3.3 集群配置进入${HBASE_HOME}/conf目录下,修改配置: hbase-env.sh 1234# 配置JDK安装位置export JAVA_HOME=/usr/java/jdk1.8.0_231# 不使用内置的zookeeper服务export HBASE_MANAGES_ZK=false hbase-site.xml 1234567891011121314151617&lt;configuration&gt; &lt;property&gt; &lt;!-- 指定 hbase 以分布式集群的方式运行 --&gt; &lt;name&gt;hbase.cluster.distributed&lt;/name&gt; &lt;value&gt;true&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;!-- 指定 hbase 在 HDFS 上的存储位置 --&gt; &lt;name&gt;hbase.rootdir&lt;/name&gt; &lt;value&gt;hdfs://hadoop001:8020/hbase&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;!-- 指定 zookeeper 的地址--&gt; &lt;name&gt;hbase.zookeeper.quorum&lt;/name&gt; &lt;value&gt;hadoop001:2181,hadoop002:2181,hadoop003:2181&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; regionservers 123masterslave1slave2 backup-masters 1slave1 注:backup-masters 这个文件是不存在的，需要新建，主要用来指明备用的 master 节点，可以是多个，这里我们以 1 个为例。 3.4 安装包分发将 HBase 的安装包分发到其他服务器，分发后建议在这两台服务器上也配置一下 HBase 的环境变量。 12scp -r /usr/local/hbase-2.0.0/ slave1:usr/local/scp -r /usr/local/hbase-2.0.0/ slave2:usr/local/ 4 启动集群4.1 启动ZooKeeper集群分别到三台服务器上启动 ZooKeeper 服务： 1zkServer.sh start 4.2 启动Hadoop集群1234# 启动dfs服务start-dfs.sh# 启动yarn服务start-yarn.sh 4.3 启动HBase集群进入 master 的 ${HBASE_HOME}/bin，使用以下命令启动 HBase 集群。执行此命令后，会在 master 上启动 Master 服务，在 slave1 上启动备用 Master 服务，在 regionservers 文件中配置的所有节点启动 region server 服务。 1start-hbase.sh 4.4 查看服务访问 HBase 的 Web-UI 界面，这里我安装的 HBase 版本为 2.0.0，访问端口为 16010，如果你安装的是 2.0 以下的版本，则访问端口号为 60010。可以看到 Master 在 master 上，三个 Regin Servers 分别在 master，slave1，和 slave2 上，并且还有一个 Backup Matser 服务在 slave1 上。 结束至此,已经在三台虚拟机上将Hadoop2.8.5,Zookeeper3.4.14以及Hbase2.0.0搭建全部结束]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>HBase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Zookeeper集群配置搭建]]></title>
    <url>%2F2020%2F05%2F08%2FZookeeper%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AE%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[1.Zookeeper集群环境搭建1.1下载下载对应版本 Zookeeper，这里我下载的版本 3.4.14。官方下载地址：https://archive.apache.org/dist/zookeeper/ 1# wget https://archive.apache.org/dist/zookeeper/zookeeper-3.4.14/zookeeper-3.4.14.tar.gz 1.2解压1# tar -zxvf zookeeper-3.4.14.tar.gz 1.3配置环境解压1# vim /etc/profile 添加环境变量: 12export ZOOKEEPER_HOME=/usr/app/zookeeper-3.4.14export PATH=$ZOOKEEPER_HOME/bin:$PATH 使得配置生效: 1# source /etc/profile 1.4修改配置进入安装目录的 conf/ 目录下，拷贝配置样本并进行修改： 1# cp zoo_sample.cfg zoo.cfg 指定数据存储目录和日志文件目录（目录不用预先创建，程序会自动创建），修改后完整配置如下： 123456789101112tickTime=2000initLimit=10syncLimit=5dataDir=/usr/local/zookeeper-cluster/data/dataLogDir=/usr/local/zookeeper-cluster/log/clientPort=2181# server.1 这个1是服务器的标识，可以是任意有效数字，标识这是第几个服务器节点，这个标识要写到dataDir目录下面myid文件里# 指名集群间通讯端口和选举端口server.1=master:2287:3387server.2=slave1:2287:3387server.3=slave2:2287:3387 配置说明: tickTime：用于计算的基础时间单元。比如 session 超时：N*tickTime； initLimit：用于集群，允许从节点连接并同步到 master 节点的初始化连接时间，以 tickTime 的倍数来表示； syncLimit：用于集群， master 主节点与从节点之间发送消息，请求和应答时间长度（心跳机制）； dataDir：数据存储位置； dataLogDir：日志目录； clientPort：用于客户端连接的端口，默认 2181 1.5 标识节点分别在三台主机的 dataDir 目录下新建 myid 文件,并写入对应的节点标识。Zookeeper 集群通过 myid 文件识别集群节点，并通过上文配置的节点通信端口和选举端口来进行节点通信，选举出 Leader 节点。创建存储目录： 12# 三台主机均执行该命令mkdir -vp /usr/local/zookeeper-cluster/data/ 创建并写入节点标识到 myid 文件： 123456# master主机echo &quot;1&quot; &gt; /usr/local/zookeeper-cluster/data/myid# slave1主机echo &quot;2&quot; &gt; /usr/local/zookeeper-cluster/data/myid# slave2主机echo &quot;3&quot; &gt; /usr/local/zookeeper-cluster/data/myid 1.5 启动分别在三台主机运行以下命令 1zkServer.sh start 1.6 验证启动后使用 zkServer.sh status 查看集群各个节点状态。]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hadoop集群搭建]]></title>
    <url>%2F2020%2F05%2F08%2Fhadoop%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[1. 基本环境1.1 三台虚拟机169.254.110.100 master 169.254.110.101 slave1 169.254.110.102 slave2 1.2 软件包jdk-8u231-linux-i586.tar.gz hadoop-2.8.5.tar.gz 2. 环境配置2.1 新建hadoop用户useradd hadoop 通过passwd命令修改hadoop用户密码，启用hadoop用户。passwd hadoop 2.2 配置ssh免密码登录2.2.1 集群环境 节点名称 节点ip master 169.254.110.100 slave1 169.254.110.101 slave2 169.254.110.102 2.2.2 免登录原理每台主机authorized_keys文件里面包含的主机（ssh密钥），该主机都能无密码登录，所以只要每台主机的authorized_keys文件里面都放入其他主机（需要无密码登录的主机）的ssh密钥就行了。 2.2.3 实现每个节点生成ssh密钥 123456789101112[root@master ~]# ssh-keygen -t rsa(一直点确定)Generating public/private rsa key pair.Enter file in which to save the key (/root/.ssh/id_rsa): Created directory &apos;/root/.ssh&apos;.Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /root/.ssh/id_rsa.Your public key has been saved in /root/.ssh/id_rsa.pub......................[root@master .ssh]# lsid_rsa id_rsa.pub 在主节点(master)将公钥(id_rsa.pub)拷到一个特定文件authorized_keys中 123[root@master .ssh]# cp id_rsa.pub authorized_keys[root@master .ssh]# lsauthorized_keys id_rsa id_rsa.pub 然后将该文件拷到下一个节点中去,并将该节点的ssh密钥追加到该文件中 123456789101112131415#在master上使用scp命令实现远程文件拷贝[root@master .ssh]# scp authorized_keys root@hadoop02:/root/.ssh/The authenticity of host &apos;hadoop02 (192.168.44.11)&apos; can&apos;t be established.ECDSA key fingerprint is SHA256:MyB1zs0E3J/fm8pC0AN8ycsgEIBNHtUqd9xS0WAyv3s.ECDSA key fingerprint is MD5:88:48:3a:ba:3e:14:a7:d7:86:f6:51:74:00:10:f9:00.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added &apos;hadoop02,192.168.44.11&apos; (ECDSA) to the list of known hosts.root@hadoop02&apos;s password: authorized_keys 100% 395 306.2KB/s 00:00 #登录slave1主机[root@slave1 ~]# cd .ssh/[root@slave1 .ssh]# lsauthorized_keys id_rsa id_rsa.pub[root@slave1 .ssh]# cat id_rsa.pub &gt;&gt; authorized_keys #使用cat追加方式 重复上步操作,将slave1的authorized_keys文件传到slave2中并将slave2中的密钥追加到该文件中.最后将slave2的authorized_keys文件传到master与slave1中 1234567#登录slave2主机，将ssh密钥加入authorized_keys文件中[root@slave2 .ssh]# cat id_rsa.pub &gt;&gt; authorized_keys #将最后生成的authorized_keys文件分别拷贝到master,slave1[root@slave2 .ssh]# scp authorized_keys root@master:/root/.ssh/[root@slave2 .ssh]# scp authorized_keys root@slave1:/root/.ssh/ 最后免密登录 2.3 修改hosts文件修改master主机hosts文件vi /etc/hosts 并添加: 123169.254.110.100 master169.254.110.101 slave1169.254.110.102 slave2 并且同步到其他主机上去 2.4 JDK安装这里不多阐述 用WinSCP传到虚拟机中然后解压并且配置环境变量 2.5 Hadoop环境配置2.5.1 上传并且解压hadoop2.8.5 hadoop-env.sh 12# 指定JDK的安装位置export JAVA_HOME=/usr/java/jdk1.8.0_201/ core-site.xml 123456789101112&lt;configuration&gt; &lt;property&gt; &lt;!--指定 namenode 的 hdfs 协议文件系统的通信地址--&gt; &lt;name&gt;fs.defaultFS&lt;/name&gt; &lt;value&gt;hdfs://master:8020&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;!--指定 hadoop 集群存储临时文件的目录--&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;value&gt;/home/hadoop/tmp&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; hdfs-site.xml 12345678910&lt;property&gt; &lt;!--namenode 节点数据（即元数据）的存放位置，可以指定多个目录实现容错，多个目录用逗号分隔--&gt; &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt; &lt;value&gt;/home/hadoop/namenode/data&lt;/value&gt;&lt;/property&gt;&lt;property&gt; &lt;!--datanode 节点数据（即数据块）的存放位置--&gt; &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt; &lt;value&gt;/home/hadoop/datanode/data&lt;/value&gt;&lt;/property&gt; yarn-site.xml 123456789101112&lt;configuration&gt; &lt;property&gt; &lt;!--配置 NodeManager 上运行的附属服务。需要配置成 mapreduce_shuffle 后才可以在 Yarn 上运行 MapReduce 程序。--&gt; &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt; &lt;value&gt;mapreduce_shuffle&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;!--resourcemanager 的主机名--&gt; &lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt; &lt;value&gt;hadoop001&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; slaves 123masterslave1slave2 2.5.2 分发程序将 Hadoop 安装包分发到其他两台服务器，分发后建议在这两台服务器上也配置一下 Hadoop 的环境变量。 1234# 将安装包分发到hadoop002scp -r /usr/home/hadoop-2.8.5-cdh5.15.2/ root@slave1:/usr/home/# 将安装包分发到hadoop003scp -r /usr/home/hadoop-2.8.5-cdh5.15.2/ root@slave2:/usr/home/ 2.6 初始化在 master 上执行 namenode 初始化命令： 1hdfs namenode -format 2.7 启动集群在master主机中进入${HADOOP_HOME}/sbin 目录下，启动 Hadoop 1234# 启动dfs服务start-dfs.sh# 启动yarn服务start-yarn.sh 3.7 查看集群在每台服务器上使用 jps 命令查看服务进程，或直接进入 Web-UI 界面进行查看，端口为 50070。 4 提交服务到集群提交作业到集群的方式和单机环境完全一致，这里以提交 Hadoop 内置的计算 Pi 的示例程序为例，在任何一个节点上执行都可以，命令如下： 1hadoop jar /usr/app/hadoop-2.6.0-cdh5.15.2/share/hadoop/mapreduce/hadoop-mapreduce-examples-2.6.0-cdh5.15.2.jar pi 3 3]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Springboot整合Thymeleaf]]></title>
    <url>%2F2019%2F09%2F03%2FSpringboot%E6%95%B4%E5%90%88Thymeleaf%2F</url>
    <content type="text"><![CDATA[thymeleaf的介绍Thymeleaf 介绍Thymeleaf 是一款用于渲染 XML/XHTML/HTML5 内容的模板引擎。类似 JSP，Velocity，FreeMaker 等，它也可以轻易的与 Spring MVC 等 Web 框架进行集成作为 Web 应用的模板引擎。与其它模板引擎相比，Thymeleaf 最大的特点是能够直接在浏览器中打开并正确显示模板页面，而不需要启动整个 Web 应用。 好了，你们说了我们已经习惯使用了什么 Velocity,FreMaker，beetle之类的模版，那么到底好在哪里呢？ 比一比吧 Thymeleaf 是与众不同的，因为它使用了自然的模板技术。这意味着 Thymeleaf 的模板语法并不会破坏文档的结构，模板依旧是有效的XML文档。模板还可以用作工作原型，Thymeleaf 会在运行期替换掉静态值。Velocity 与 FreeMarke r则是连续的文本处理器。 下面的代码示例分别使用 Velocity、FreeMarker 与 Thymeleaf 打印出一条消息： 123Velocity: &lt;p&gt;$message&lt;/p&gt;FreeMarker: &lt;p&gt;$&#123;message&#125;&lt;/p&gt;Thymeleaf: &lt;p th:text=&quot;$&#123;message&#125;&quot;&gt;Hello World!&lt;/p&gt; 注意，由于 Thymeleaf 使用了 XML DOM 解析器，因此它并不适合于处理大规模的 XML 文件。 添加Jar包12345&lt;!-- thymelaef模板 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; 添加配置文件123456789101112#Thymeleaf配置#开发时关闭缓存,不然没法看到实时页面spring.thymeleaf.cache=falsespring.thymeleaf.check-template=true# 模板模式设置，默认为HTML5spring.thymeleaf.mode=HTML5spring.thymeleaf.check-template-location=truespring.thymeleaf.encoding=UTF-8spring.thymeleaf.prefix=classpath:/templates/spring.thymeleaf.servlet.content-type=text/htmlspring.thymeleaf.suffix=.html 模板中引入thymeleaf1&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt; thymeleaf部分语法URLURL 在 Web 应用模板中占据着十分重要的地位，需要特别注意的是 Thymeleaf 对于 URL 的处理是通过语法 @{…} 来处理的。Thymeleaf 支持绝对路径 URL： 1&lt;a th:href=&quot;@&#123;http://www.thymeleaf.org&#125;&quot;&gt;Thymeleaf&lt;/a&gt; 条件求值 1&lt;a th:href=&quot;@&#123;/login&#125;&quot; th:unless=$&#123;session.user != null&#125;&gt;Login&lt;/a&gt; for循环 12345&lt;tr th:each=&quot;prod : $&#123;prods&#125;&quot;&gt; &lt;td th:text=&quot;$&#123;prod.name&#125;&quot;&gt;Onions&lt;/td&gt; &lt;td th:text=&quot;$&#123;prod.price&#125;&quot;&gt;2.41&lt;/td&gt; &lt;td th:text=&quot;$&#123;prod.inStock&#125;? #&#123;true&#125; : #&#123;false&#125;&quot;&gt;yes&lt;/td&gt;&lt;/tr&gt; thymeleaf中文文档Thymeleaf中文文档]]></content>
      <categories>
        <category>study</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Thymeleaf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Springboot整合Jpa]]></title>
    <url>%2F2019%2F09%2F01%2FSpringboot%E6%95%B4%E5%90%88Jpa%2F</url>
    <content type="text"><![CDATA[添加jar包12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt; 添加配置文件12345678spring.datasource.url=jdbc:mysql://localhost:3306/testspring.datasource.username=rootspring.datasource.password=123456spring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.jpa.properties.hibernate.hbm2ddl.auto=updatespring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL5InnoDBDialectspring.jpa.show-sql= true spring.jpa.properties.hibernate.hbm2ddl.auto这个参数的作用在于:自动创建,更新,验证数据库表的结构有以下是四个值: 1 create： 每次加载 hibernate 时都会删除上一次的生成的表，然后根据你的 model 类再重新来生成新表，哪怕两次没有任何改变也要这样执行，这就是导致数据库表数据丢失的一个重要原因。 2 create-drop ：每次加载 hibernate 时根据 model 类生成表，但是 sessionFactory 一关闭,表就自动删除。 3 update：最常用的属性，第一次加载 hibernate 时根据 model 类会自动建立起表的结构（前提是先建立好数据库），以后加载 hibernate 时根据 model 类自动更新表结构，即使表结构改变了但表中的行仍然存在不会删除以前的行。要注意的是当部署到服务器后，表结构是不会被马上建立起来的，是要等 应用第一次运行起来后才会。 4 validate ：每次加载 hibernate 时，验证创建数据库表结构，只会和数据库中的表进行比较，不会创建新表，但是会插入新值。 dialect主要是指定生成表名的存储引擎为InnoDBD show-sql是否打印出自动生成的SQL,方便调试的时候查看 添加实体类与数据表进行映射,并且配置好映射关系 12345678910111213141516171819202122232425@Entity@Data@AllArgsConstructor@NoArgsConstructorpublic class User implements Serializable &#123; private static final long serialVersionUID = 1L; @Id //设置主键 @GeneratedValue //id自增 private Long id; @Column(nullable = false,unique = true) //用户名不为空且唯一 private String userName; @Column(nullable = false) private String passWord; @Column(nullable = false) private String email; @Column(nullable = false) private String nickName; @Column(nullable = false) private String regTime;&#125; 设置DAO层dao 只要继承 JpaRepository 类就可以，几乎可以不用写方法，还有一个特别有尿性的功能非常赞，就是可以根据方法名来自动的生成 SQL，比如findByUserName 会自动生成一个以 userName 为参数的查询方法，比如 findAlll 自动会查询表里面的所有数据，比如自动分页等等。。 123456789@Repositorypublic interface UserRepository extends JpaRepository&lt;User,Long&gt; &#123; User findByUserName(String userName); User findByUserNameAndPassWord(String userName,String password); User findByUserNameOrEmail(String userName,String Email);&#125; 添加Service层UserService.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public interface UserService &#123; /** * * 功能描述: 添加用户 * * @param: user * @return: User * @auther: zy * @date: 2019/9/1 15:05 */ User saveUser(User user); /** * * 功能描述: 删除用户 * * @param: id * @return: void * @auther: zy * @date: 2019/9/1 15:06 */ void removeUser(Long id); /** * * 功能描述: 更新用户信息 * * @param: user * @return: User * @auther: zy * @date: 2019/9/1 15:06 */ User updateUser(User user); /** * * 功能描述: 通过id得到用户 * * @param: id * @return: User * @auther: zy * @date: 2019/9/1 15:06 */ User getUserByNameAndPassword(String userName,String passWord); /** * * 功能描述: 得到所有用户信息 * * @param: null * @return: List&lt;User&gt; * @auther: zy * @date: 2019/9/1 15:07 */ List&lt;User&gt; getAllUsers(); UserServiceImpl.java 1234567891011121314151617181920212223242526272829303132@Servicepublic class UserServiceImpl implements UserService &#123; @Autowired UserRepository userRepository; @Override public User saveUser(User user) &#123; return userRepository.save(user); &#125; @Override public void removeUser(Long id) &#123; userRepository.deleteById(id); &#125; @Override public User updateUser(User user) &#123; return userRepository.save(user); &#125; @Override public User getUserByNameAndPassword(String userName, String passWord) &#123; return userRepository.findByUserNameAndPassWord(userName,passWord); &#125; @Override public List&lt;User&gt; getAllUsers() &#123; return userRepository.findAll(); &#125;&#125; 控制层(Controller)123456789101112131415161718192021@RestControllerpublic class HelloController &#123; @Autowired UserService userService; @GetMapping(&quot;/users&quot;) public User getUser()&#123; // 获取当前时间 Date date = new Date(); DateFormat dateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); String time = dateFormat.format(date); User user = new User(1L,&quot;zzy001&quot;,&quot;f695112338&quot;,&quot;zyf695112338@qq.com&quot;,&quot;金毛玲&quot;,time); userService.saveUser(user); return user; &#125;&#125; Demo结果 demo]]></content>
      <categories>
        <category>study</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>JPA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis--jdbcType报错]]></title>
    <url>%2F2019%2F08%2F12%2FBuilderException-%20Error%20resolving%20JdbcType%2F</url>
    <content type="text"><![CDATA[问题启动tomcat的时候报错 12345678910111213141516171819` Caused by: org.apache.ibatis.builder.BuilderException: Error parsing Mapper XML. Cause: org.apache.ibatis.builder.BuilderException: Error resolving JdbcType. Cause: java.lang.IllegalArgumentException: No enum constant org.apache.ibatis.type.JdbcType.DATATIME at org.apache.ibatis.builder.xml.XMLMapperBuilder.configurationElement(XMLMapperBuilder.java:120) at org.apache.ibatis.builder.xml.XMLMapperBuilder.parse(XMLMapperBuilder.java:92) at org.mybatis.spring.SqlSessionFactoryBean.buildSqlSessionFactory(SqlSessionFactoryBean.java:521) ... 84 moreCaused by: org.apache.ibatis.builder.BuilderException: Error resolving JdbcType. Cause: java.lang.IllegalArgumentException: No enum constant org.apache.ibatis.type.JdbcType.DATATIME at org.apache.ibatis.builder.BaseBuilder.resolveJdbcType(BaseBuilder.java:73) at org.apache.ibatis.builder.xml.XMLMapperBuilder.buildResultMappingFromContext(XMLMapperBuilder.java:382) at org.apache.ibatis.builder.xml.XMLMapperBuilder.resultMapElement(XMLMapperBuilder.java:280) at org.apache.ibatis.builder.xml.XMLMapperBuilder.resultMapElement(XMLMapperBuilder.java:252) at org.apache.ibatis.builder.xml.XMLMapperBuilder.resultMapElements(XMLMapperBuilder.java:244) at org.apache.ibatis.builder.xml.XMLMapperBuilder.configurationElement(XMLMapperBuilder.java:116) ... 86 moreCaused by: java.lang.IllegalArgumentException: No enum constant org.apache.ibatis.type.JdbcType.DATATIME at java.lang.Enum.valueOf(Enum.java:238) at org.apache.ibatis.type.JdbcType.valueOf(JdbcType.java:25) at org.apache.ibatis.builder.BaseBuilder.resolveJdbcType(BaseBuilder.java:71) ... 91 more` 原因看报错的原因,是因为我在resultmap中jdbcType写了datatime,而在mybatis中是这个数据类型的 解决办法修改resultmap中的jdbcType即可 Tip我去网上查看了源码,发现mybatis的jdbcType是一个枚举类,有以下类型: 12345678910111213141516171819202122232425262728293031323334353637383940public enum JdbcType &#123; ARRAY(2003), BIT(-7), TINYINT(-6), SMALLINT(5), INTEGER(4), BIGINT(-5), FLOAT(6), REAL(7), DOUBLE(8), NUMERIC(2), DECIMAL(3), CHAR(1), VARCHAR(12), LONGVARCHAR(-1), DATE(91), TIME(92), TIMESTAMP(93), BINARY(-2), VARBINARY(-3), LONGVARBINARY(-4), NULL(0), OTHER(1111), BLOB(2004), CLOB(2005), BOOLEAN(16), CURSOR(-10), UNDEFINED(-2147482648), NVARCHAR(-9), NCHAR(-15), NCLOB(2011), STRUCT(2002), JAVA_OBJECT(2000), DISTINCT(2001), REF(2006), DATALINK(70), ROWID(-8), LONGNVARCHAR(-16), SQLXML(2009), DATETIMEOFFSET(-155); 总结希望以后自己能越过这个坎,多长记性.]]></content>
      <categories>
        <category>study</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[idea--target不同步问题]]></title>
    <url>%2F2019%2F08%2F09%2F%E5%85%B3%E4%BA%8Eidea%E4%B8%ADtarget%E4%B8%8D%E5%90%8C%E6%AD%A5%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[问题所在ssm小项目中,加入了新的css文件和js文件,然后重启项目,发现并没有效果.然鹅在页面中也及时的引用了相关的css和js文件. 分析原因我使用的idea编译器,发现target文件中并没有相关的css和js文件,导致我在页面中引入了等同于没有引用,所以导致页面没有相关的效果. 解决办法先清理项目中的target目录,然后再rebuild项目即可 12//清理target目录mvn clean package 然后rebuild项目(快捷键Ctrl+Shift+F9) 解决问题ok拉!!]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>idea</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习笔记:Mybatis-PageHelper]]></title>
    <url>%2F2019%2F07%2F17%2FMybatis%E4%B9%8BPagehelper%2F</url>
    <content type="text"><![CDATA[前言Mybatis为我们提供了非常优秀的分页插件PageHelper该插件支持任何复杂的单表或者是多表. PageHelper实现了通用的分页查询,支持的数据有mysql,Oracle,DB2,PostgreSQL等该插件托管于github: https://github.com/pagehelper/Mybatis-PageHelper如何使用PageHelper导入依赖- 使用maven导入12345678910&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;3.4.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.jsqlparser&lt;/groupId&gt; &lt;artifactId&gt;jsqlparser&lt;/artifactId&gt; &lt;version&gt;0.9.1&lt;/version&gt;&lt;/dependency&gt; 导入jar包1). 你可以从下面的地址中下载最新版本的 jar 包 https://oss.sonatype.org/content/repositories/releases/com/github/pagehelper/pagehelper/ http://repo1.maven.org/maven2/com/github/pagehelper/pagehelper/ 2). 由于使用了sql 解析工具，你还需要下载 jsqlparser.jar： http://repo1.maven.org/maven2/com/github/jsqlparser/jsqlparser/0.9.5/配置拦截器插件特别注意，新版拦截器是 com.github.pagehelper.PageInterceptor com.github.pagehelper.PageHelper 现在是一个特殊的 dialect 实现类，是分页插件的默认实现类，提供了和以前相同的用法。 在Mybatis配置xml中配置拦截器插件123456&lt;plugins&gt; &lt;plugin interceptor=&quot;com.github.pagehelper.PageInterceptor&quot;&gt; &lt;!--分页参数合理化 --&gt; &lt;property name=&quot;reasonable&quot; value=&quot;true&quot;/&gt; &lt;/plugin&gt; &lt;/plugins&gt; 在Spring配置文件中配置拦截器插件使用 spring 的属性配置方式，可以使用 plugins 属性像下面这样配置： 123456789101112131415&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;!-- 注意其他配置 --&gt; &lt;property name=&quot;plugins&quot;&gt; &lt;array&gt; &lt;bean class=&quot;com.github.pagehelper.PageInterceptor&quot;&gt; &lt;property name=&quot;properties&quot;&gt; &lt;!--使用下面的方式配置参数，一行配置一个 --&gt; &lt;value&gt; params=value1 &lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/array&gt; &lt;/property&gt;&lt;/bean&gt; 确确实实去配置文件会让人显得很郁闷也很头疼. 所以我一般参照官方文档去配置,里面不仅有分页插件的参数介绍还有常用的配置参数,不同的场景需要配置不同的参数. 参考PageHelper官方文档 DAO层在我做的demo中,我是获取所有部门然后在使用分页插件进行物理分页. 1234public interface DepartmentMapper &#123; //获取所有部门 List&lt;Department&gt; getAll();&#125; Service层1234public interface DepartmentService &#123;//查询所有 List&lt;Department&gt; getAll();&#125; 实现相应的接口 12345678910@Servicepublic class DepartmentServiceImpl implements DepartmentService &#123; @Autowired DepartmentMapper departmentMapper; @Override public List&lt;Department&gt; getAll() &#123; return departmentMapper.getAll(); &#125;&#125; Controller层在控制器中,是跳转到部门的页面的时候将数据查询到然后使用PageHelper 1234567891011121314151617181920212223242526272829303132/** * @project : HRM * @description : 控制器-首页管理 * @author : zy */@Controller@RequestMapping(&quot;main&quot;)public class MainController &#123; @Autowired UserService userService; @Autowired DepartmentService departmentService; @Autowired EmployeeService employeeService; /** * @decription 查询所有部门信息并跳转到部门信息页面(分页查询) * @param model * @return */ @RequestMapping(&quot;toDepartmentList.html&quot;) public String toDepartmentList(@RequestParam(value = &quot;pn&quot;, defaultValue = &quot;1&quot;) Integer pn, Model model)&#123; //pn为当前页码,每页的大小为5 PageHelper.startPage(pn,5); List&lt;Department&gt; departmentList = departmentService.getAll(); //导航栏最多为5页 PageInfo pageInfo = new PageInfo(departmentList,5); model.addAttribute(&quot;pageInfo&quot;,pageInfo); return &quot;Dep/DepartmentList&quot;;&#125;&#125; 使用PageHelper的静态方法:PageHelper.startPage(currentPage,PageSize)(currentPage是指的当前页数PageSize是指的是每页的大小) 使用PageInfo对象在使用PageHelper.start后,我们可以使用PageInfo进行封装,可以从PageInfo中获得更多的信息,比如:当前页码,最后页码等等(详情5.3) 这里使用进行了分页封装,departmentList实际上是一个代理对象. 1PageInfo pageInfo = new PageInfo(departmentList,5); PageInfo的属性参数,成员变量1234567891011121314151617181920212223242526272829303132333435363738394041//当前页private int pageNum; //每页的数量private int pageSize; //当前页的数量private int size;//总记录数private long total; //总页数private int pages; //结果集(每页显示的数据)private List&lt;T&gt; list; //第一页private int firstPage; //前一页private int prePage; //是否为第一页private boolean isFirstPage = false; //是否为最后一页private boolean isLastPage = false; //是否有前一页private boolean hasPreviousPage = false; //是否有下一页private boolean hasNextPage = false; //导航页码数private int navigatePages; //所有导航页号private int[] navigatepageNums; View层(JSP)这里使用了test12345678910111213141516171819202122232425262728293031323334```&lt;div class=&quot;&quot; style=&quot;position: fixed;left: 500px;top: 490px;&quot;&gt; 当前 $&#123;pageInfo.pageNum&#125; 页,总 $&#123;pageInfo.pages&#125; 页,总 $&#123;pageInfo.total&#125; 条记录 &lt;/div&gt; &lt;div class=&quot;&quot; style=&quot;position: fixed;right: 500px;top: 460px;&quot;&gt; &lt;nav aria-label=&quot;Page navigation&quot;&gt; &lt;ul class=&quot;pagination&quot;&gt; &lt;li&gt;&lt;a href=&quot;/main/toDepartmentList.html?pn=1&quot;&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;c:if test=&quot;$&#123;pageInfo.hasPreviousPage&#125;&quot;&gt; &lt;li&gt; &lt;a href=&quot;/main/toDepartmentList.html?pn=$&#123;pageInfo.pageNum-1&#125;&quot; aria-label=&quot;Previous&quot;&gt; &lt;span aria-hidden=&quot;true&quot;&gt;&amp;laquo;&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;/c:if&gt; &lt;c:forEach items=&quot;$&#123;pageInfo.navigatepageNums&#125;&quot; var=&quot;pagenum&quot;&gt; &lt;c:if test=&quot;$&#123;pagenum == pageInfo.pageNum&#125;&quot;&gt; &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;/main/toDepartmentList.html?pn=$&#123;pagenum&#125;&quot;&gt;$&#123;pagenum&#125;&lt;/a&gt;&lt;/li&gt; &lt;/c:if&gt; &lt;c:if test=&quot;$&#123;pagenum != pageInfo.pageNum&#125;&quot;&gt; &lt;li&gt;&lt;a href=&quot;/main/toDepartmentList.html?pn=$&#123;pagenum&#125;&quot;&gt;$&#123;pagenum&#125;&lt;/a&gt;&lt;/li&gt; &lt;/c:if&gt; &lt;/c:forEach&gt; &lt;c:if test=&quot;$&#123;pageInfo.hasNextPage&#125;&quot;&gt; &lt;li&gt; &lt;a href=&quot;/main/toDepartmentList.html?pn=$&#123;pageInfo.pageNum+1&#125;&quot; aria-label=&quot;Next&quot;&gt; &lt;span aria-hidden=&quot;true&quot;&gt;&amp;raquo;&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/main/toDepartmentList.html?pn=$&#123;pageInfo.pages&#125;&quot;&gt;末页&lt;/a&gt;&lt;/li&gt; &lt;/c:if&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;/div&gt; demo截图 ZOuKRP.jpg 结尾第一次写笔记,感觉自己还是做的很不够,思路不够清晰,写的不太好也写的太慢… 希望自己能够在以后写的越来越好. 可爱的猫猫]]></content>
      <categories>
        <category>study</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客备份]]></title>
    <url>%2F2019%2F07%2F17%2FHexo%E5%8D%9A%E5%AE%A2%E5%A4%87%E4%BB%BD%2F</url>
    <content type="text"><![CDATA[关于hexo博客备份使用 Hexo 在 GitHub Pages 搭建博客时，博客作为一个单独的 GitHub 仓库存在，但是这个仓库只有生成的静态网页文件，并没有 Hexo 的源文件。这样一来换电脑或者重装系统后，再想找回源文件就比较麻烦了，这里推荐一种比较完美的方法解决备份问题。 备份 创建仓库 WincerChan.github.io，如果同名仓库之前已经创建，请将之前的仓库改名新建的仓库必须是 Username.github.io（如果你是将 Hexo 博客部署到了自己的服务器，那么仓库名可以随意设置，我这里就是随意设置的仓库） 创建两个分支：master 和 hexo； 设置 hexo 为默认分支 将刚刚创建的新仓库 clone 至本地，将之前的 hexo 文件夹中的 _config.yml、themes/、source/、scaffolds/、package.json 和 .gitignore 复制至 WincerChan.github.io 文件夹 将 themes/next/（我用的是 NexT 主题）中的 .git/ 删除，否则无法将主题文件夹 push（也可以将主题文件夹使用子模块的方式添加到该仓库) 在 WincerChan.github.io 文件夹执行 npm install 和 npm install hexo-deployer-git（这里可以看一看分支是不是显示为 hexo） 执行 git add、git commit -m “”、git push origin hexo 来提交 hexo 网站源文件； 执行 hexo g -d 生成静态网页部署至 Github 上 修改 依次执行 git add、git commit -m “” 和 git push origin hexo 来提交 hexo 网站源文件 执行 hexo g -d 生成静态网页部署至 Github 上 恢复 安装 git 安装Nodejs和npm 使用 git clone git#github.com:WincerChan/WincerChan.github.io.git 将仓库拷贝至本地 在文件夹内执行以下命令 npm install hexo-cli -g、npm install、npm install hexo-deployer-git]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git basic command]]></title>
    <url>%2F2019%2F07%2F17%2Fgit-basic-command%2F</url>
    <content type="text"><![CDATA[###Git 基本命令 git init (命令把这个目录变成Git可以管理的仓库)12$ git initInitialized empty Git repository in /Users/michael/learngit/.git/ git add (将文件添加到仓库)1git add readme.txt git commit (将文件提交到仓库)1234$ git commit -m &quot;wrote a readme file&quot;[master (root-commit) eaadf4e] wrote a readme file 1 file changed, 2 insertions(+) create mode 100644 readme.txt (这里git commit -m “这里是添加本次提交的说明”git add 是可以添加多个文件,而git commit是可以一次提交多个的) git status (查看当前仓库的状态)123456789$ git statusOn branch masterChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: readme.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) (这里表示readme.txt是已经修改了,但是还没有提交修改) git diff (查看不同(difference))123456789$ git diff readme.txt diff --git a/readme.txt b/readme.txtindex 46d49bf..9247db6 100644--- a/readme.txt+++ b/readme.txt@@ -1,2 +1,2 @@-Git is a version control system.+Git is a distributed version control system. Git is free software. git log (命令显示从最近到最远的提交日志)123456789101112131415161718$ git logcommit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master)Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Fri May 18 21:06:15 2018 +0800 append GPLcommit e475afc93c209a690c39c13a46716e8fa000c366Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Fri May 18 21:03:36 2018 +0800 add distributedcommit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Fri May 18 20:59:18 2018 +0800 wrote a readme file (如果嫌输出信息太多，看得眼花缭乱的，可以试试加上–pretty=oneline参数：) 1234$ git log --pretty=oneline1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master) append GPLe475afc93c209a690c39c13a46716e8fa000c366 add distributedeaadf4e385e865d25c48e7ca9c8395c3f7dfaef0 wrote a readme file]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F06%2F25%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
