<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[设计模式之单例模式(Singleton)]]></title>
    <url>%2F2020%2F12%2F03%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F-Singleton%2F</url>
    <content type="text"><![CDATA[定义在很多系统中，为了节省内存资源，保证数据内容的一致性，对于某些类只创建一个实例（有且只有一个）,即所谓的单例模式 （因为在我的毕设IM项目中写了很多单例模式，所以前来总结一下） 优缺点 优点： 正如定义中提到，为了保证内存中只有一个实例，减少内存的开销 避免对于资源的多重占用 保证每一次调用的数据内容一致性 缺点： 单例模式没有接口，拓展困难，如果要拓展功能则需要修改源代码，这违背了开闭原则 在并发测试中，单例模式不利于代码调试，在调试过程中，如果单例中的代码没有执行完，也不能模拟生成一个新的对象。 因为实现了单例模式的类通常需要完成多个功能，这很容易违背了单一职责原则 应用场景对于 Java 来说，单例模式可以保证在一个 JVM 中只存在单一实例。单例模式的应用场景主要有以下几个方面。 需要频繁创建的一些类，使用单例可以降低系统的内存压力，减少 GC。 某类只要求生成一个对象的时候，如一个班中的班长、每个人的身份证号等。 某些类创建实例时占用资源较多，或实例化耗时较长，且经常使用。 某类需要频繁实例化，而创建的对象又频繁被销毁的时候，如多线程的线程池、网络连接池等。 频繁访问数据库或文件的对象。 对于一些控制硬件级别的操作，或者从系统上来讲应当是单一控制逻辑的操作，如果有多个实例，则系统会完全乱套。 当对象需要被共享的场合。由于单例模式只允许创建一个对象，共享该对象可以节省内存，并加快对象访问速度。如 Web 中的配置对象、数据库的连接池等。 结构与模式结构单例模式的主要角色如下。 单例类：包含一个实例且能自行创建这个实例的类。 访问类：使用单例的类。 单例模式的结构图 实现单例模式的实现有两种： 懒汉式 饿汉式 针对懒汉和饿汉又有多种实现 懒汉 静态变量 1234567public class Singleton&#123; // 静态变量保存实例变量 public static final Singleton INSTANCE = new Singleton(); // 构造器私有化，防止new 创建实例 public Singleton()&#123; &#125;&#125; 优点 由于使用了static关键字，保证了在引用这个变量时，关于这个变量的所有写入操作都完成，所以保证了JVM层面的线程安全。 缺点 不能实现懒加载，造成空间浪费。如果一个类比较大，我们在初始化的时就加载了这个类，但是我们长时间没有使用这个类，这就导致了内存空间的浪费。 枚举 123public enum Singleton&#123; INSTANCE;&#125; 这种方式是最简洁的，不需要考虑构造方法私有化。值得注意的是枚举类不允许被继承，因为枚举类编译后默认为final class，可防止被子类修改。常量类可被继承修改、增加字段等，容易导致父类的不兼容。枚举类型是线程安全的，并且只会装载一次，设计者充分的利用了枚举的这个特性来实现单例模式，枚举的写法非常简单，而且枚举类型是所有单例实现中唯一一种不会被破坏的单例实现模式 静态代码块 12345678public class Singleton&#123; // 构造器私有化 private Singleton()&#123;&#125; public static final Singleton INSTANCE; static&#123; INSTANCE = new Singleton(); &#125;&#125; 这种方式和上面的静态常量/变量类似，只不过把new放到了静态代码块里，从简洁程度上比不过第一种。但是把new放在static代码块有别的好处，那就是可以做一些别的操作，如初始化一些变量，从配置文件读一些数据等。 饿汉 DCL 12345678910111213141516171819/** * 懒汉模式-线程安全，适用于多线程 */public class Singleton&#123; private static volatile Singleton INSTANCE;//防止指令重排 private LazySafeSingleton() &#123; &#125; public static Singleton getInstance()&#123; if(INSTANCE==null)&#123; synchronized (Singleton.class)&#123; if(INSTANCE==null)&#123;//双重检测 INSTANCE = new LazySafeSingleton(); &#125; &#125; &#125; return INSTANCE; &#125;&#125; 这里懒汉式创建单例采用了双重检查锁（DCL）,因为在多线程的环境下，当两个线程同时执行第一个判空时，都满足的情况下，都会进来，然后去争锁，假设线程1拿到了锁，执行同步代码块的内容，创建了实例并返回，此时线程2又获得锁，执行同步代码块内的代码，因为此时线程1已经创建了，所以线程2虽然拿到锁了，如果内部不加判空的话，线程2会再new一次，导致两个线程获得的不是同一个实例。 而对于volatile关键字主要是防止指令重排（可以去了解下JVM的指令重排） 内部类创建 12345678910public class Singleton&#123; private Singleton() &#123; &#125; private static class Inner&#123; private static final Singleton INSTANCE = new Singleton(); &#125; public static Singleton getInstance()&#123; return Inner.INSTANCE; &#125;&#125; 该方式天然线程安全，是否final根据自己需要 总结对于这几种实现方式，只有枚举类才能阻止反射方式破坏单例 如果单例类实现了序列化接口Serializable, 就可以通过反序列化破坏单例]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之建造者模式]]></title>
    <url>%2F2020%2F11%2F29%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[1. 定义对于一个复杂对象，我们将其构造与其表示分离开，也就是说我们可以分阶段的去构造一个对象的属性。 它是将一个复杂的对象分解为多个简单的对象，然后一步一步构建而成。它将变与不变相分离，即产品的组成部分是不变的，但每一部分是可以灵活选择的。 2. 结构与实现2.1 结构建造者（Builder）模式由: 产品，抽象建造者，具体建造者，指挥者 产品（Product） 是包含许多组件的复杂对象，由具体建造者来创建其各个组件 抽象建造者（Builder）是包含创建产品各个组件的接口，通常还包含一个返回复杂产品的方法getProduct（） 具体建造者（Concrete Builder）是实现Builder接口，完成复杂产品的各个组件的具体创建方法 指挥者（Director）是调用建造者对象中的组件构造以及装配去完成复杂对象的建立 建造者模式的结构图 2.2 实现Product.java 123456789101112131415161718192021222324252627282930313233package com.enoch.designmode.builder;/** * @Author yang.zhao * @Date 2020/11/26 16:25 * @Version 1.0 * @Description 产品包含许多组建的复杂对象 **/public class Product &#123; private String partA; private String partB; private String partC; public void setPartA(String partA) &#123; this.partA = partA; &#125; public void setPartB(String partB) &#123; this.partB = partB; &#125; public void setPartC(String partC) &#123; this.partC = partC; &#125; public void show()&#123; System.out.println(this.toString()); &#125;&#125; Builder.java 123456789101112131415161718192021222324package com.enoch.designmode.builder;/** * @Author yang.zhao * @Date 2020/11/26 16:28 * @Version 1.0 * @Description 包含创建产品各个组件的抽象方法 **/public abstract class Builder &#123; //创建产品对象 protected Product product=new Product(); public abstract void buildPartA(); public abstract void buildPartB(); public abstract void buildPartC(); //返回产品对象 public Product getResult() &#123; return product; &#125;&#125; ConcreteBuilder.java 123456789101112131415161718192021222324package com.enoch.designmode.builder;/** * @Author yang.zhao * @Date 2020/11/26 16:28 * @Version 1.0 * @Description 实现建造者的抽象方法 **/public class ConcreteBuilder extends Builder&#123; @Override public void buildPartA() &#123; product.setPartA("建造 PartA"); &#125; @Override public void buildPartB() &#123; product.setPartA("建造 PartB"); &#125; @Override public void buildPartC() &#123; product.setPartA("建造 PartC"); &#125;&#125; Director.java 123456789101112131415161718192021222324252627package com.enoch.designmode.builder;/** * @Author yang.zhao * @Date 2020/11/26 16:30 * @Version 1.0 * @Description 调用建造者的方法完成复杂对象的创建 **/public class Director &#123; private Builder builder; public Director(Builder builder)&#123; this.builder = builder; &#125; /** * 构建产品 * @return */ public Product construct() &#123; builder.buildPartA(); builder.buildPartB(); builder.buildPartC(); return builder.getResult(); &#125;&#125; Main.java 12345678910111213141516package com.enoch.designmode.builder;/** * @Author yang.zhao * @Date 2020/11/26 16:33 * @Version 1.0 * @Description **/public class Main &#123; public static void main(String[] args) &#123; Builder builder = new ConcreteBuilder(); Director director = new Director(builder); Product product = director.construct(); product.show(); &#125;&#125;]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>代理模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之模板方法模式]]></title>
    <url>%2F2020%2F11%2F16%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[1. 定义模板方法(template): 定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。它是一种类行为型模式。 2. 特点2.1 优点 它封装了不变部分，扩展可变部分。它把认为是不变部分的算法封装到父类中实现，而把可变部分算法由子类继承实现，便于子类继续扩展。 它在父类中提取了公共的部分代码，便于代码复用。 部分方法是由子类实现的，因此子类可以通过扩展方式增加相应的功能，符合开闭原则。 2.2 缺点 对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象，间接地增加了系统实现的复杂度。 父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，它提高了代码阅读的难度。 由于继承关系自身的缺点，如果父类添加新的抽象方法，则所有子类都要改一遍。 3. 模式的结构与实现3.1 结构 模板抽象类: 给出一个算法的大概轮廓(可以有实现的方法,也可以没有),应该有一个钩子函数去调用基本方法,供子类继承去重写抽象方法 具体实现类: 提供子类去继承实现模板抽象类. 3.2 实现AbstractTemplate.java 123456789101112131415161718192021222324252627282930package designmode.template;/** * @Author: zy * @Date: 2020/11/16 23:39 * @Description: 模板抽象类 */public abstract class AbstractTemplate &#123; /** * 钩子函数(用于调用所有基本函数) */ public void hookMethod()&#123; abstract1(); specificMethod(); &#125; /** * 模板方法(需要子类去实现) */ public abstract void abstract1(); /** * 已经实现的方法 */ public void specificMethod()&#123; System.out.println("invoke specificMethod()..."); &#125;&#125; ConcreteClass.java 12345678910111213package designmode.template;/** * @Author: zy * @Date: 2020/11/16 23:43 * @Description: 具体子类 */public class ConcreteClass extends AbstractTemplate&#123; @Override public void abstract1() &#123; System.out.println("concreteClass invoke abstract1"); &#125;&#125; Main.java 12345678910111213package designmode.template;/** * @Author: zy * @Date: 2020/11/16 23:44 * @Description: */public class Main &#123; public static void main(String[] args) &#123; AbstractTemplate demo = new ConcreteClass(); demo.hookMethod(); &#125;&#125;]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之代理模式(Proxy)]]></title>
    <url>%2F2020%2F11%2F13%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[1. 定义代理模式(proxy): 当我们不对目标对象的源码进行修改或者说不能直接调用目标对象。就需要使用到代理对象去访问目标对象。代理对象充当中介 2. 结构与实现2.1. 结构 代理模式的主要角色有 抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。 真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。 代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。 代理模式的结构图 根据代理的创建时期，代理模式可以分为静态代理和动态代理 静态：显式的创建代理类去生成源代码在进行编译 动态：在程序的运行时候，运用反射机制创建而成的 2.2. 实现Subject.java 12345678910111213package designmode.proxy;/** * @Author: zy * @Date: 2020/11/13 22:49 * @Description: 代理对象和目标对象都要实现的接口,并且重写里面的方法 */public interface Subject &#123; /** * 共同需要实现的方法 */ void action();&#125; RealSubject.java 1234567891011121314package designmode.proxy;/** * @Author: zy * @Date: 2020/11/13 22:52 * @Description: 目标对象 */public class RealSubject implements Subject&#123; @Override public void action() &#123; System.out.println("目标对象执行action()..."); &#125;&#125; Proxy.java 123456789101112131415161718192021222324252627package designmode.proxy;/** * @Author: zy * @Date: 2020/11/13 22:54 * @Description: 代理对象 */public class Proxy implements Subject&#123; private RealSubject realSubject = new RealSubject(); @Override public void action() &#123; if(realSubject == null)&#123; realSubject = new RealSubject(); &#125; preAction(); realSubject.action(); orderAction(); &#125; public void preAction()&#123; System.out.println("执行action()前..."); &#125; public void orderAction()&#123; System.out.println("执行action()后..."); &#125;&#125; Main.java 12345678910111213package designmode.proxy;/** * @Author: zy * @Date: 2020/11/13 23:00 * @Description: */public class Main &#123; public static void main(String[] args) &#123; Proxy proxy = new Proxy(); proxy.action(); &#125;&#125; 12]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之观察者模式(Observer)]]></title>
    <url>%2F2020%2F11%2F12%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[1. 定义观察者(Observe)模式: 指多个对象存在一对多的依赖关系. 当一个对象的状态发生改变的时候,所有依赖它的对象都能得到通知并且得到更新. 又称为 发布-订阅模式 2. 特点2.1. 优点 降低了目标与观察者对象的之间耦合度.两者是抽象耦合关系 目标和观察者之前存在一种触发机制 2.2. 缺点 目标和观察者之间的耦合度并没有完全解除,还是会出现循环引用 当观察者对象很多的时候,通知的发布会发生很多时间,影响程序的效率 3. 模式的实现3.1. 结构观察者模式的主要角色如下。 抽象主题（Subject）角色：也叫抽象目标类，它提供了一个用于保存观察者对象的聚集类和增加、删除观察者对象的方法，以及通知所有观察者的抽象方法。 具体主题（Concrete Subject）角色：也叫具体目标类，它实现抽象目标中的通知方法，当具体主题的内部状态发生改变时，通知所有注册过的观察者对象。 抽象观察者（Observer）角色：它是一个抽象类或接口，它包含了一个更新自己的抽象方法，当接到具体主题的更改通知时被调用。 具体观察者（Concrete Observer）角色：实现抽象观察者中定义的抽象方法，以便在得到目标的更改通知时更新自身的状态。 观察者模式的结构图 3.2. 实现Subject.java 1234567891011121314151617181920212223242526272829303132333435package designmode.observe;import java.util.ArrayList;import java.util.List;/** * @Author: zy * @Date: 2020/11/12 23:25 * @Description: */public abstract class Subject &#123; protected List&lt;Observer&gt; observers = new ArrayList&lt;Observer&gt;(); /** * 增加观察者 * @param observer */ public void add(Observer observer) &#123; observers.add(observer); &#125; /** * 删除观察者方法 * @param observer */ public void remove(Observer observer) &#123; observers.remove(observer); &#125; /** * 通知观察者抽象方法 */ public abstract void notifyObserver();&#125; ConcreteSubject.java 1234567891011121314151617181920212223242526272829303132333435package designmode.observe;import java.util.ArrayList;import java.util.List;/** * @Author: zy * @Date: 2020/11/12 23:25 * @Description: */public abstract class Subject &#123; protected List&lt;Observer&gt; observers = new ArrayList&lt;Observer&gt;(); /** * 增加观察者 * @param observer */ public void add(Observer observer) &#123; observers.add(observer); &#125; /** * 删除观察者方法 * @param observer */ public void remove(Observer observer) &#123; observers.remove(observer); &#125; /** * 通知观察者抽象方法 */ public abstract void notifyObserver();&#125; Observe.java 12345678910111213package designmode.observe;/** * @Author: zy * @Date: 2020/11/12 23:25 * @Description: */public interface Observer &#123; /** * 观察者作出响应 */ void response();&#125; ConcreteObserver1.java 12345678910111213package designmode.observe;/** * @Author: zy * @Date: 2020/11/12 23:30 * @Description: 具体观察者1 */public class ConcreteObserver1 implements Observer&#123; @Override public void response() &#123; System.out.println("具体观察者1作出反应！"); &#125;&#125; ConcreteObserver2.java 12345678910111213package designmode.observe;/** * @Author: zy * @Date: 2020/11/12 23:31 * @Description: 具体观察者2 */public class ConcreteObserver2 implements Observer&#123; @Override public void response() &#123; System.out.println("具体观察者2作出反应！"); &#125;&#125; Main.java 1234567891011121314151617package designmode.observe;/** * @Author: zy * @Date: 2020/11/12 23:35 * @Description: */public class Main &#123; public static void main(String[] args) &#123; Subject subject = new ConcreteSubject(); Observer obs1 = new ConcreteObserver1(); Observer obs2 = new ConcreteObserver2(); subject.add(obs1); subject.add(obs2); subject.notifyObserver(); &#125;&#125;]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 51.N-Queues]]></title>
    <url>%2F2020%2F11%2F09%2FLeetCode-51-N-Queues%2F</url>
    <content type="text"><![CDATA[题目n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。 N-queues 上图为 8 皇后问题的一种解法。 给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。 每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。 示例12345678910111213输入：4输出：[ [&quot;.Q..&quot;, // 解法 1 &quot;...Q&quot;, &quot;Q...&quot;, &quot;..Q.&quot;], [&quot;..Q.&quot;, // 解法 2 &quot;Q...&quot;, &quot;...Q&quot;, &quot;.Q..&quot;]]解释: 4 皇后问题存在两个不同的解法。 题解12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import java.util.ArrayList;import java.util.List;/** * @Author: zy * @Date: 2020/11/7 21:31 * @Description: */public class SolveNQueens &#123; private List&lt;List&lt;String&gt;&gt; res; private int[][] used; public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123; if(n == 0) return res; used = new int[n][n]; res = new ArrayList&lt;&gt;(); DFS(0); return res; &#125; public void DFS(int index)&#123; if(index == used.length)&#123; List&lt;String&gt; temp = new ArrayList&lt;&gt;(); for(int i = 0 ; i &lt; used.length ; i++)&#123; StringBuilder sb = new StringBuilder(); for(int j = 0 ; j &lt; used.length ; j++)&#123; if(used[i][j] == 0)&#123; sb.append(&quot;.&quot;); &#125;else&#123; sb.append(&quot;Q&quot;); &#125; &#125; temp.add(sb.toString()); &#125; res.add(temp); return; &#125; for(int i = 0 ; i &lt; used.length ; i++)&#123; if(validUsed(i,index))&#123; used[i][index] = 1; DFS(index + 1); used[i][index] = 0; &#125; &#125; &#125; public boolean validUsed(int x,int y)&#123; // 当前行是否可以放置(只考虑y左边的部分,因为我们是每一列来进行放置的,右边的肯定为0) for(int i = 0 ; i &lt; y ; i++)&#123; if(used[x][i] == 1)&#123; return false; &#125; &#125; int x1 = x; int y1 = y; // 对角线是否可以放置,也只是考虑y左边的部分,道理同上 while(x1 &gt; 0 &amp;&amp; y1 &gt; 0)&#123; if(used[--x1][--y1] == 1)&#123; return false; &#125; &#125; x1 = x; y1 = y; while(x1 &lt; used.length &amp;&amp; y1 &gt;= 0)&#123; if(used[x1++][y1--] == 1)&#123; return false; &#125; &#125; return true; &#125;&#125;]]></content>
      <categories>
        <category>study</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 88. Merge(Easy)]]></title>
    <url>%2F2020%2F11%2F05%2FLeetCode-88-Merge%2F</url>
    <content type="text"><![CDATA[题目给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。 说明 初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。 你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。 示例12345输入：nums1 = [1,2,3,0,0,0], m = 3nums2 = [2,5,6], n = 3输出：[1,2,2,3,5,6] 题解123456789101112131415161718192021222324252627/** * @Author: zy * @Date: 2020/11/5 20:39 * @Description: */public class Merge88 &#123; public void merge(int[] nums1, int m, int[] nums2, int n) &#123; int len = nums1.length - 1; while(m &gt; 0 &amp;&amp; n &gt; 0)&#123; if(nums1[m - 1] &gt;= nums2[n - 1])&#123; nums1[len--] = nums1[m - 1]; m--; &#125;else&#123; nums1[len--] = nums2[n- 1]; n--; &#125; &#125; while(m &gt; 0)&#123; nums1[len--] = nums1[m - 1]; m--; &#125; while(n &gt; 0)&#123; nums1[len--] = nums2[n - 1]; n--; &#125; &#125;&#125;]]></content>
      <categories>
        <category>study</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 101 isSymmetria(Easy)]]></title>
    <url>%2F2020%2F11%2F04%2FLeetCode-101-isSymmetria%2F</url>
    <content type="text"><![CDATA[题目请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。 例如，二叉树 [1,2,2,3,4,4,3] 是对称的。 12345 1 / \ 2 2 / \ / \3 4 4 3 但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的: 12345 1 / \ 2 2 / \ / \3 4 4 3 示例123456789示例 1：输入：root = [1,2,2,3,4,4,3]输出：true示例 2：输入：root = [1,2,2,null,3,null,3]输出：false 题解12345678910111213141516171819202122232425262728import binarytree.TreeNode;/** * @Author: zy * @Date: 2020/11/4 18:48 * @Description: */public class IsSymmetric101 &#123; public boolean isSymmetric(TreeNode root) &#123; // 若root为null 则直接返回true 因为空树满足对称 if(root == null)&#123; return true; &#125; return solution(root,root.left,root.right); &#125; public boolean solution(TreeNode root,TreeNode left,TreeNode right)&#123; if(root == null)&#123; return true; &#125; // 若left和right同时为null 才返回true if(left == null || right == null)&#123; return left == null &amp;&amp; right == null; &#125; //进行值比较以及进一步递归遍历left.right,right.left 和 left.left,right.right return left.val == right.val &amp;&amp; solution(root,left.right,right.left) &amp;&amp; solution(root,left.left,right.right); &#125;&#125;]]></content>
      <categories>
        <category>study</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>BinaryTree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 234. isPalindrome(Easy)]]></title>
    <url>%2F2020%2F11%2F04%2FLeetCode-234-isPalindrome%2F</url>
    <content type="text"><![CDATA[题目请判断一个链表是否为回文链表。 示例12345678示例 1:输入: 1-&gt;2输出: false示例 2:输入: 1-&gt;2-&gt;2-&gt;1输出: true 题解1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import LinkedList.ListNode;/** * @Author: zy * @Date: 2020/11/4 14:03 * @Description: */public class IsPalindrome234 &#123; public boolean isPalindrome(ListNode head) &#123; if(head == null)&#123; return true; &#125; //获取中间节点 ListNode mid = findMid(head); //反转后面部分的节点并且返回后半部的开始节点 ListNode secondStart = reserve(mid.next); //然后进行一一比较 while(secondStart != null)&#123; if(head.val != secondStart.val)&#123; return false; &#125; head = head.next; secondStart = secondStart.next; &#125; return true; &#125; public ListNode reserve(ListNode head)&#123; ListNode pre = null; // 用以连接反转后的节点 ListNode tail = head; while(head != null)&#123; ListNode next = head.next; head.next = pre; pre = head; head = next; &#125; tail = head; return pre; &#125; /** * 通过快慢指针返回中间节点(slow) **/ public ListNode findMid(ListNode head)&#123; ListNode slow = head; ListNode fast = head.next; while(fast != null &amp;&amp; fast.next != null)&#123; slow = slow.next; fast = fast.next.next; &#125; return slow; &#125;&#125;]]></content>
      <categories>
        <category>study</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 146. LRUCache(Medium)]]></title>
    <url>%2F2020%2F09%2F01%2FLeetCode-146-LRUCache%2F</url>
    <content type="text"><![CDATA[题目运用你所掌握的数据结构，设计和实现一个 LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。 获取数据 get(key) - 如果关键字 (key) 存在于缓存中，则获取关键字的值（总是正数），否则返回 -1。写入数据 put(key, value) - 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字/值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。 练习地址LeetCode 示例1234567891011LRUCache cache = new LRUCache( 2 /* 缓存容量 */ );cache.put(1, 1);cache.put(2, 2);cache.get(1); // 返回 1cache.put(3, 3); // 该操作会使得关键字 2 作废cache.get(2); // 返回 -1 (未找到)cache.put(4, 4); // 该操作会使得关键字 1 作废cache.get(1); // 返回 -1 (未找到)cache.get(3); // 返回 3cache.get(4); // 返回 4 解题思路所谓LRU 即 最近最少使用.我们需要的就是完成两个操作(get()以及put()). 这里我们采用HashMap和双向链表进行实现 在get()操作中: ​ 我们每一次进行get()操作,需要进行判断该元素是否存在,若不存在即返回-1. 若存在我们需要返回该值 并且我们需要将该值放置首位代表最近使用. 在put()操作中: ​ 根据不同的情况我们有三种不同的操作: 当前元素不存在,即正常插入 当前元素存在,我们需要对元素进行删除并且将该元素插入首位 容量满,我们需要删除最末尾的元素然后添加元素 代码Node.java 12345678910111213141516package LeetCode.LRU;/** * @Auther: zy * @Date: 2020/9/1 14:48 * @Description: */public class Node &#123; public int key, val; public Node next, prev; public Node(int k, int v)&#123; this.key = k; this.val = v; &#125;&#125; LRUCache.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101package LeetCode.LRU;import java.util.HashMap;import java.util.Map;/** * @Auther: zy * @Date: 2020/9/1 14:48 * @Description: */public class LRUCache &#123; //容量 private int capacity; Map&lt;Integer,Node&gt; map; Node head = new Node(0,0); Node tail = new Node(0,0); public LRUCache(int cap) &#123; this.capacity = cap; map = new HashMap&lt;&gt;(); head.next = tail; tail.prev = head; &#125; /** * 思路(先该存储后改映射关系) * &lt;p&gt; * 1. 未存在 * 2. 已存在 * * @param key * @return */ public int get(int key) &#123; if (!map.containsKey(key)) &#123; return -1; &#125; //获取值 int res = map.get(key).val; put(key, res); return res; &#125; /** * 1. 判断是否存在,若存在先找到该元素(通过hash映射找到对应位置然后在链表中进行删除),然后再头插法添加节点, 最后再添加映射关系 * 2. 若是容量已满,先对链表的最后一个元素进行删除(返回该删除的节点),通过返回的节点进行删除map中的映射关系 * * @param key * @param val */ public void put(int key, int val) &#123; Node node = new Node(key, val); // 已存在key if (map.containsKey(key)) &#123; // 找到该元素并删除 remove(map.get(key)); // 头插法添加节点 addFirst(node); // 添加映射关系 map.put(key, node); &#125; else &#123; // 未存在但容量满 if (capacity == map.size()) &#123; // 删除最后一个节点,并且返回该节点 Node last = removeLast(); // 删除map映射关系 map.remove(last.key); &#125; // 正常添加 addFirst(node); map.put(key, node); &#125; &#125; public void addFirst(Node node)&#123; Node next = head.next; node.next = next; node.prev = head; head.next = node; next.prev = node; &#125; public Node removeLast()&#123; Node last = tail.prev; last.prev.next = tail; tail.prev = last.prev; return last; &#125; public void remove(Node node)&#123; Node next = node.next; node.prev.next = next; next.prev = node.prev; &#125;&#125;]]></content>
      <categories>
        <category>study</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer 06. ReservePrint (Easy)]]></title>
    <url>%2F2020%2F08%2F31%2F%E5%89%91%E6%8C%87Offer-06-ReservePrint%2F</url>
    <content type="text"><![CDATA[题目输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。 示例12输入：head = [1,3,2]输出：[2,3,1] 在线练习you can practice online: LeetCode 解题思路 我们先进行对链表的逆置(双指针) ,然后我们对链表进行遍历的同时向数组中添加元素 Timecomplexity: O(N) – N为链表长度 SpaceComplexity: O(N) 我们进行第一次遍历获取到链表的长度n,然后再进行一次遍历向数组中添加元素 Timecomplexity: O(N) – N为链表长度 SpaceComplexity: O(N) 可以采用辅助栈的做法(栈: 先进后出)直接每一次弹出元素就加入数组中 Timecomplexity: O(N) – N为链表长度 SpaceComplexity: O(N)– 额外使用一个栈存储链表中的每个节点 可以采用递归的手段,我们递归的最后一个节点然后回溯时添加元素向数组中 Timecomplexity: O(N) – N为链表长度 SpaceComplexity: O(N)– N为栈深度 代码这里我采用前两种方法进行解决 Method 1: 12345678910111213141516171819public int[] reversePrint(ListNode head) &#123; if(head == null) return new int[]&#123;&#125;; int n = 0; ListNode pre = null; ListNode cur = head; while(cur != null)&#123; ListNode next = cur.next; cur.next = pre; pre = cur; cur = next; n++; &#125; int[] arr = new int[n]; for(int i = 0 ; i &lt; n; i++)&#123; arr[i] = pre.val; pre = pre.next; &#125; return arr;&#125; Method 2: 1234567891011121314public int[] reversePrint(ListNode head) &#123; if(head == null) return new int[]&#123;0&#125;; int n = 0; ListNode cur = head; while (cur != null)&#123; n++; cur = cur.next; &#125; int[] arr = new int[n]; for(int i = n - 1; i &gt;= 0; i--)&#123; arr[i] = head.val; head = head.next; &#125; return arr;]]></content>
      <categories>
        <category>study</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer 18. 删除链表节点]]></title>
    <url>%2F2020%2F08%2F25%2F%E5%89%91%E6%8C%87Offer-18-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E8%8A%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[最近面试在刷题,由于很多中小型企业笔试中不会出现算法题,最近的重点先放在Java复习以及MySQL. LC随缘刷 题目给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。 返回删除后的链表的头节点。 practice online 示例123输入: head = [4,5,1,9], val = 5输出: [4,1,9]解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9. 123输入: head = [4,5,1,9], val = 1输出: [4,5,9]解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9. 解题思路我们需要判断每个节点的大小是否等于val因此要遍历整个链表,之后我们需要删除指定节点我们需要知道该节点的前继节点pre,我们直接从第二个节点循环开始判断(第一个我们先进行判断如果head.val == val直接返回head.next) TimeComplexity:O(N) 因为要进行遍历链表 SpaceComplexity:O(1) 代码1234567891011121314151617181920212223242526/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode deleteNode(ListNode head, int val) &#123; if(head.val == val) return head.next; ListNode pre = head; ListNode cur = pre.next; while(cur != null)&#123; if(cur.val == val)&#123; pre.next = cur.next; break; &#125; else&#123; pre = pre.next; cur = pre.next; &#125; &#125; return head; &#125;&#125;]]></content>
      <categories>
        <category>study</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 154. MinArray(Easy)]]></title>
    <url>%2F2020%2F08%2F18%2FLeetCode-154-MinArray%2F</url>
    <content type="text"><![CDATA[题目把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。 来源LeetCode练习 示例示例 1： 12输入：[3,4,5,1,2]输出：1 示例 2： 12输入：[2,2,2,0,1]输出：0 解题思路根据题意我们可以得知在进行数组的旋转之前这是一个递增数组并且可能含有重复数字. 最容易想到的方法: 1. 暴力法我们从数组的第一个元素开始进行遍历将前后进行对比,如果numbers[left] &gt; numbers[right]则已经出现转折(前后分别是两个不同的可能递增的数组).此时right就是我们要找的最小的元素下标.返回numbers[right]即可.也有可能全部数组都是重复的一个数字,我们在进行遍历结束后都没有找到符合条件的numbers[left]&gt;numbers[right]我们就直接返回数组的一个数(默认下标为0的数) 2. 二分法我们在进行传统的二分查找时候,数组必须是要有序的,因为此时我们才能对于一个数进行对比后判断要找的数在它的左区间或者右区间.以便减少查找的次数. 而在本题中其实是满足的二分法的(因为在分界处两边都是单调的数组),我们需要找的就是找到这个分界处. 例如示例1中: ​ 我们取2个下标left,right(默认为第一个和最后一个),然后得到中间下标mid(mid = left + (right - left)/2)—这里有个小细节:我们得到中间的数不是用的(left + right)/2 因为这样当left和right很大的时候相加会出现溢出. 其实后面除以2 我更愿意改成 &gt;&gt; 1 因为位运算更快.)所以进行一个循环条件是(left &lt; right) 当number[mid] &gt;number[right]的时候说明mid前面是一个递增的,临界处在mid的右边,将left指针移动到mid+1处 当number[mid] &lt; number[right]的时候说明mid右边是一个递增的,临界处在mid的左边,所以将right指针指向mid处即可 当number[mid] = number[right] 的时候说明数组里面有重复的数字,我们不清楚临界处是在mid的左边还是右边,我们需要做的是将right--即可. 最后返回number[right] 代码1. 暴力法12345678910111213141516class Solution &#123; public int minArray(int[] numbers) &#123; if(numbers.length == 0) return 0; int res = 0; for(int i = 0; i &lt; numbers.length; i++)&#123; int left = i; int right = left + 1; if(right == numbers.length) break; if(numbers[left] &gt; numbers[right])&#123; res = right; break; &#125; &#125; return numbers[res]; &#125;&#125; 2. 二分法12345678910111213141516public static int minArray(int[] numbers) &#123; int i = 0; int j = numbers.length - 1; if(numbers[i] &lt; numbers[j] || numbers.length == 1) return numbers[i]; while (i &lt; j) &#123; int mid = i + (j - i)/2; if(numbers[mid] &lt;= numbers[j])&#123; j = mid; &#125;else if(numbers[mid] &gt; numbers[j])&#123; i = mid + 1; &#125;else &#123; j--; &#125; &#125; return numbers[j]; &#125;]]></content>
      <categories>
        <category>study</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构之图(Graph)]]></title>
    <url>%2F2020%2F08%2F15%2F%E5%9B%BE-Graph%2F</url>
    <content type="text"><![CDATA[概念简单来说，图是一种用来表示相连数据的数据结构，类似我们的社交网络，图中有很多的节点，每个节点代表一个数据，每个节点可以和其他节点相连。其中每个节点叫做顶点（vertice）,连接顶点之间的线叫做相连线（edge） img 在此图中，我们含有5个顶点和6条相连线，每个顶点包含了人名，而连接线代表相连人名之间是朋友关系。如果我们要更正式地表示图，那么图就可以用一对（V，E）集合来表示，其中V是一堆顶点的集合，而E是一堆相连线的集合 V = {a,b,c,d,e} E={ab,ac,,bd,cd,de} 上述是无向图 图的分类有三种: 无向图 有向图 权重图 无向图比较容易理解,连线没有方向,有向图则是存在连线方向的(可以理解成账号之间的关注问题,若A指向B,则表示A关注了B,若B也关注了A,则存在双向箭头),而权重图则是连线之间有值(可以理解成朋友之间的亲密度值). 其中有向图使用的比较多. 有向图的表示邻接矩阵 img 每行代表相应的顶点，如果M[i][j] = 1，那么就代表顶点 i 连向 j，如果是0，则表达顶点间没有联系. 优点:可以很清楚的知道两个顶点是否相连 缺点:因为我们要浪费很多空间来保存没有关联的两个点的信息.用矩阵实现的时间复杂度很高，我们需要O(V^2)来记录所有的数据 邻接表针对邻接矩阵的缺点,我们可以采用邻接表的方式来只保存有关系的两个点(通过链表实现) img Java实现代码: 12345678910111213141516171819202122232425import java.util.ArrayList;/** * @Auther: zy * @Date: 2020/8/15 14:32 * @Description: 图的实现(链表) */public class ListGraph &#123; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; graphs; public ListGraph(int val)&#123; graphs = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; val; i++) &#123; graphs.add(new ArrayList&lt;&gt;()); &#125; &#125; public void addEdge(int start,int end)&#123; graphs.get(start).add(end); &#125; public void removeEdge(int start,int end)&#123; graphs.get(start).remove((Integer) end); &#125;&#125; 有向图的实现很简单，我们直接使用Java中的ArrayList来代表左侧的数组和数组上的链表，其中两个重要方法addEdge和removeEdge直接使用ArrayList自带的方法add和remove即可。使用链表的形式来实现图，我们可以只记录有用的数据，省下了很多空间 图的遍历图的遍历方式有两种,一种是深度优先搜索（Depth-first Search），另一种是宽度优先搜索（Breadth-first search） DFS(深度优先搜索)图的深度优先搜索跟树的先序遍历很类似.在深度优先遍历中，我们假设初始状态所有顶点都没被访问，然后从每一顶点v出发，先访问该顶点，然后依次从它的各个未被访问的邻接点出发，深度优先遍历图，直到图中所有和v相通的顶点都被访问到。若遍历完后，还有其他顶点没被访问到，则另选一个未被访问的顶点作为起始点，重复上述过程，直到所有顶点都被访问完为止 img 具体的遍历顺序 1234567访问A访问B（在访问A之后，接下来应该访问的是A出发的另一个顶点，既顶点B）访问C（在访问B之后，接下来访问的是从B出发的另一个顶点，既C，E，F。在此图中，我们按照字母排序顺序访问，因此先访问C。）访问E（接下来访问与C连接的另一个顶点E。）访问D（接下来访问从E出发的顶点B和D，因为B已被访问过，所以访问顶点D。）访问F（接下来回溯“访问A的另一个连接顶点F”）访问G BFS(广度优先搜索)广度优先搜索算法也叫做“宽度优先搜索”或“横向优先搜索”,它跟树的层次遍历有些类似,其方法是从图中的某一顶点v出发，在访问了v之后依次访问v的各个没有访问到的邻接点，然后分别从这些邻接点出发依次访问他们的邻接点，使得先被访问的顶点的邻接点先与后被访问顶点的邻接点被访问，直到图中所有已被访问的顶点的邻接点都被访问到。如果此时图中尚有顶点未被访问，则需要另选一个未曾被访问到的顶点作为新的起始点，重复上述过程，直至图中所有顶点都被访问到为止。换句话说，广度优先搜索遍历图的过程是以v为起点，由近至远，依次访问和v有路径相通且路径长度为1，2，…的顶点 img 具体的遍历顺序: 1234访问A访问B依次访问C，E，F（在B被访问之后，接下来访问B的邻接点，既C，E，F。）依次访问D，G（在访问完C，E，F之后，再依次访问他们出发的另一个顶点。还是按照C，E，F的顺序访问，C的已经全部访问过了，那么就只剩下E，E；先访问E的邻接点D，再访问F的邻接点G。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899package com.enoch.algorithm.graph;import java.util.ArrayDeque;import java.util.Deque;import java.util.Iterator;/** * @Auther: zy * @Date: 2020/8/15 14:37 * @Description: 图的遍历(DFS,BFS) */public class GraphTraversal &#123; ListGraph graph; //遍历过的值 boolean[] visited; public GraphTraversal(ListGraph listGraph)&#123; this.graph = listGraph; visited = new boolean[listGraph.graphs.size()]; &#125; public void DFS()&#123; for (int i = 0; i &lt; graph.graphs.size(); i++) &#123; if(!visited[i])&#123; DFSTraversal(i); &#125; &#125; &#125; public void BFS()&#123; for (int i = 0; i &lt; graph.graphs.size(); i++) &#123; if(!visited[i])&#123; BFSTraversal(i); &#125; &#125; &#125; public void DFSTraversal(int v)&#123; //判断是否访问过 if(visited[v]) return; //将该点加入已访问的boolean数组中 visited[v] = true; System.out.print(v + "-&gt;"); //通过listIterator遍历拿到该节点的相邻节点集合 Iterator&lt;Integer&gt; neighbors = graph.graphs.get(v).listIterator(); while (neighbors.hasNext())&#123; // 循环遍历该节点的相邻节点并递归访问 int nextNode = neighbors.next(); if(!visited[nextNode])&#123; DFSTraversal(nextNode); &#125; &#125; &#125; public void BFSTraversal(int v)&#123; if(visited[v]) return; // 创建一个双向队列来保存某节点的相邻节点 // 使用队列的原因是因为一个节点的相邻节点比下一个节点的相邻节点要先访问(符合 队列的先进先出) Deque&lt;Integer&gt; queue = new ArrayDeque&lt;&gt;(); visited[v] = true; queue.addFirst(v); while(!queue.isEmpty())&#123; Integer cur = queue.pollFirst(); System.out.print(cur + "-&gt;"); Iterator&lt;Integer&gt; neighbors = graph.graphs.get(cur).listIterator(); while (neighbors.hasNext())&#123; Integer nextNode = neighbors.next(); // 每一次访问该节点后把该节点的相邻节点 添加到队列的尾部 if(!visited[nextNode])&#123; queue.offerLast(nextNode); visited[nextNode] = true; &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; ListGraph listGraph = new ListGraph(8); listGraph.addEdge(1,2); listGraph.addEdge(2,3); listGraph.addEdge(2,4); listGraph.addEdge(2,5); listGraph.addEdge(3,5); listGraph.addEdge(4,7); listGraph.addEdge(5,2); listGraph.addEdge(5,6); listGraph.addEdge(6,3); GraphTraversal graphTraversal = new GraphTraversal(listGraph); graphTraversal.BFS(); &#125;&#125;]]></content>
      <categories>
        <category>study</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Graph</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 105. buildTree(Medium)]]></title>
    <url>%2F2020%2F08%2F13%2FLeetCode-105-buildTree%2F</url>
    <content type="text"><![CDATA[题目该是出自剑指Offer 输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 在线练习LeetCode : https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/ 牛客网: https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6?tpId=13&amp;&amp;tqId=11157&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking 示例:12前序遍历 preorder = [3,9,20,15,7]中序遍历 inorder = [9,3,15,20,7] 返回的二叉树 12345 3 / \9 20 / \ 15 7 解题思路根据前序遍历的性质，第一个元素必然就是root，那么下面的工作就是如何确定root的左右子树的范围 根据中序遍历的性质，root元素前面都是root的左子树，后面都是root的右子树.那么我们只要找到中序遍历中root的位置，就可以确定好左右子树的范围 而我们每次就可以通过前序中序之间的关系确定: 前序: 根节点–左子树–右子树 中序: 左子树–根节点–右子树 每一次递归的结束条件就是前序序列是否为空或者长度为1. 代码123456789101112131415161718192021222324252627282930313233343536373839/** * @Auther: zy * @Date: 2020/8/13 17:05 * @Description: 重建二叉树(前序和中序数组) * * * 前序遍历序列&#123;1,2,4,7,3,5,6,8&#125; 和 中序遍历序列&#123;4,7,2,1,5,3,8,6&#125; * */public class ReConstructBinaryTreeDemo &#123; public TreeNode reConstructBinaryTree(int[] pre,int[] in)&#123; // 判断当前序遍历的数列为空时 if(pre.length == 0) return null; //获取前序遍历的第一个数(因为前序遍历的第一个数一定是根节点的值) int rootVal = pre[0]; //如果数组长度为1,则只存在根节点直接返回 if(pre.length == 1) return new TreeNode(rootVal); TreeNode root = new TreeNode(rootVal); //获取根节点在中序遍历中的下标 int rootIndex = 0; for(int i = 0; i &lt; in.length; i++)&#123; if(rootVal == in[i])&#123; rootIndex = i; break; &#125; &#125; //只需要将确定的左右子树安到root上即可.递归要注意出口 //这里注意Arrays.copyOfRange(int[],start,end)是[)的区间 root.left = reConstructBinaryTree(Arrays.copyOfRange(pre,1,rootIndex+1),Arrays.copyOfRange(in,0,rootIndex)); root.right = reConstructBinaryTree(Arrays.copyOfRange(pre,rootIndex+1, pre.length),Arrays.copyOfRange(in,rootIndex+1,in.length)); return root; &#125;&#125;]]></content>
      <categories>
        <category>study</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>BinaryTree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手撕快速排序(QuickSort)]]></title>
    <url>%2F2020%2F08%2F13%2F%E6%89%8B%E6%92%95%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F-QuickSort%2F</url>
    <content type="text"><![CDATA[基本思想快速排序其实是对冒泡排序的一种改进.通过每一趟排序将要排序的数放在合适的位置,并且将要排序的数据分为两部分(其中一部分均比该数小,另一部分均比该数大).然后再不断的对两部分数据进行排序 代码直接上代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/** * @Auther: zy * @Date: 2020/8/13 14:42 * @Description: 快速排序 * 时间复杂度O(nlogn) */public class QuickSort &#123; private int[] array; public QuickSort(int[] array)&#123; this.array = array; &#125; public void sort()&#123; quickSort(array,0,array.length-1); &#125; public void quickSort(int[] array,int start,int end)&#123; if(start &lt; end)&#123; int index = array[start]; int i = start; int j = end; //当i == j时退出循环 while (i &lt; j)&#123; //找到第一个下标j的数小于index,否则j-- while(array[j] &gt;= index &amp;&amp; j &gt; i)&#123; j--; &#125; if(i &lt; j)&#123; array[i] = array[j]; i++; &#125; //找到第一个下标为i大于index的数,否则i++ while (array[i] &lt;= index &amp;&amp; i &lt; j)&#123; i++; &#125; if(i &lt; j)&#123; array[j] = array[i]; j--; &#125; array[i] = index; &#125; //将每一次排序后从已排好数的位置分为两部分再次排序 //此时i的位置就是已排序数的位置(即分为start - i-1 和 i+1 - end)两部分 quickSort(array,start,i-1); quickSort(array,i+1,end); &#125; &#125; public void print()&#123; for (int i = 0; i &lt; array.length - 1; i++) &#123; System.out.print(array[i]); &#125; System.out.println(); &#125; public static void main(String[] args) &#123; int[] num = &#123;5,9,1,9,5,3,7,6,1&#125;; QuickSort quickSort = new QuickSort(num); quickSort.sort(); quickSort.print(); &#125;&#125;]]></content>
      <categories>
        <category>study</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java三种代理模式]]></title>
    <url>%2F2020%2F08%2F13%2FJava%E4%B8%89%E7%A7%8D%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[代理模式代理(Proxy) 是一种设计模式,提供了对目标对象另外的访问方式;即通过代理对象访问目标对象. 这样做的好处: 在不改变目标对象的基础上,可以对目标对象进行功能的拓展 静态代理静态代理在使用时,需要定义接口或者父类,被代理对象与代理对象一起实现相同的接口或者是继承相同父类. 案例定义一个接口ISing,在其中定义一个方法sing() 12345678/** * @Auther: zy * @Date: 2020/8/13 11:07 * @Description: 接口 */public interface ISing &#123; void sing();&#125; 定义一个目标对象Singer实现该接口并且重写其sing()方法 1234567891011/** * @Auther: zy * @Date: 2020/8/13 11:07 * @Description: 接口实现,目标对象 */public class Singer implements ISing &#123; @Override public void sing() &#123; System.out.println("唱歌"); &#125;&#125; 这里再定义一个代理对象StaticProxy同时也实现ISing接口并重写sing()方法(加上新功能),然后通过调用代理对象来对目标对象进行调用 123456789101112131415161718192021/** * @Auther: zy * @Date: 2020/8/13 11:11 * @Description: 代理对象,静态代理 */public class StaticProxy implements ISing&#123; //保存目标对象 private ISing target; public StaticProxy(ISing target)&#123; this.target = target; &#125; @Override public void sing() &#123; System.out.println("唱歌前"); target.sing(); System.out.println("唱歌后"); &#125;&#125; 定义测试类Test 1234567891011121314151617/** * @Auther: zy * @Date: 2020/8/13 11:12 * @Description: 测试类 */public class Test &#123; public static void main(String[] args) &#123; // 目标对象 Singer singer = new Singer(); //代理对象,把目标对象传给代理对象,建立代理关系 StaticProxy staticProxy = new StaticProxy(singer); staticProxy.sing(); //执行代理方法 &#125;&#125; 总结 优点: 可以做到在不修改目标对象的功能前提下,对目标功能扩展. 缺点: 因为代理对象需要与目标对象实现一样的接口,所以会有很多代理类,类太多.同时,一旦接口增加方法,目标对象与代理对象都要维护 动态代理(JDK代理) 动态代理相比静态代理,前者的代理对象可以不实现接口 代理对象的生成,是利用JDK的API,动态的在内存中构建代理对象(需要我们指定创建代理对象/目标对象实现的接口的类型) 案例接口的定义和目标对象实现接口 与 静态代理一样不需要改变 12345678/** * @Auther: zy * @Date: 2020/8/13 11:36 * @Description: 接口 */public interface ISing &#123; void sing();&#125; 1234567891011/** * @Auther: zy * @Date: 2020/8/13 11:37 * @Description: 目标对象 实现接口 */public class Singer implements ISing &#123; @Override public void sing() &#123; System.out.println("唱歌"); &#125;&#125; 因为Java底层封装实现的细节. 直接调用Proxy类的静态方法newProxyInstance,该方法会返回代理对象 static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces,InvocationHandler h ) 接收的三个参数依次为: ClassLoader loader：指定当前目标对象使用类加载器，写法固定 Class&lt;?&gt;[] interfaces：目标对象实现的接口的类型，写法固定 InvocationHandler h：事件处理接口，需传入一个实现类，一般直接使用匿名内部类 定义测试类Test 1234567891011121314151617181920212223242526/** * @Auther: zy * @Date: 2020/8/13 11:38 * @Description: 测试类(动态代理jdk) */public class Test &#123; public static void main(String[] args) &#123; //目标对象 Singer target = new Singer(); ISing proxy = (ISing) Proxy.newProxyInstance( target.getClass().getClassLoader(), target.getClass().getInterfaces(), new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println("向观众问好"); // 执行目标对象方法 Object returnValue = method.invoke(target,args); System.out.println("谢谢大家"); return returnValue; &#125; &#125;); proxy.sing(); &#125;&#125; 总结 优点: 由于Java封装了newProxyInstance这个方法的实现细节,我们使用起来会非常的方便 缺点: 可以看出静态代理和JDK代理有一个共同的缺点，就是目标对象必须实现一个或多个接口，如何没有接口实现，则可以使用Cglib代理 Cglib代理(子类代理)前提条件 需要引入cglib的jar文件，由于Spring的核心包中已经包括了Cglib功能，所以也可以直接引入spring核心包 目标类不能为final 目标对象的方法如果为final/static，那么就不会被拦截，即不会执行目标对象额外的业务方法 案例目标对象(不需要实现接口) 1234567891011/** * @Auther: zy * @Date: 2020/8/13 12:15 * @Description: 目标对象(不需要实现接口 ) */public class Singer &#123; public void sing()&#123; System.out.println("唱歌"); &#125;&#125; Cglib代理工厂 12345678910111213141516171819202122232425262728293031323334/** * @Auther: zy * @Date: 2020/8/13 12:16 * @Description: Cglib子类代理工厂 */public class CglibProxy implements MethodInterceptor &#123; // 维护目标对象 private Object target; public CglibProxy(Object target)&#123; this.target = target; &#125; // 给目标对象创建一个代理对象 public Object getProxyInstance()&#123; // 1.工具类 Enhancer en = new Enhancer(); // 2.设置父类 en.setSuperclass(target.getClass()); // 3.设置回调函数 en.setCallback(this); // 4.创建子类 return en.create(); &#125; @Override public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123; System.out.println("向观众问好"); Object returnValue = method.invoke(target,objects); System.out.println("谢谢大家"); return returnValue; &#125;&#125; 测试类 123456789101112131415/** * @Auther: zy * @Date: 2020/8/13 12:23 * @Description: 代理类 */public class Test &#123; public static void main(String[] args) &#123; // 目标对象 Singer target = new Singer(); // 获取代理对象 Singer proxy = (Singer) new CglibProxy(target).getProxyInstance(); // 执行代理对象的方法 proxy.sing(); &#125;&#125; 总结三种代理模式各有优缺点和相应的适用范围 例如: 静态代理和动态代理(JDK代理)都需要实现接口,但是动态代理中由于Java封装了实现的细节,所以我们只需要调用Proxy类中的newProxyInstance静态方法即可,而静态代理是需要我们手动实现代理类的细节 动态代理与Cglib代理的区别,主要看目标对象是否实现了接口 在Spring框架中选择的代理模式(在Spring的AOP编程中): 如果加入容器的目标对象有实现接口，用JDK代理 如果目标对象没有实现接口，用Cglib代理]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Proxy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手撕归并排序(MERGE-SORT)]]></title>
    <url>%2F2020%2F08%2F05%2F%E6%89%8B%E6%92%95%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F-MERGE-SORT%2F</url>
    <content type="text"><![CDATA[基本思想归并排序(MERGE-SORT) 该算法运用到 分治思想 所谓分治: 分 就是将问题分成一系列小的问题然后递归求解 治 就是将各阶段的答案进行修补在一起 分(divide)分阶段可以理解为就是递归拆分子序列的过程，递归深度为log2n. 我们对于一个数组例如{3,1,4,5,2,7,8,1},我们先进行分操作:将长度为n的数组分成两个长度为n/2的数组(假设start和end分别代表各数组的第一个元素和最后一个元素) 我们在不断递归进行拆分数组的时候,终止条件就是当(start &gt;= end)—反过来也就是当(start &lt; end)执行递归拆分 代码123456789101112131415public static void sort(int[] arr)&#123; int[] temp = new int[arr.length]; sort(arr,0,arr.length-1,temp);&#125;public static void sort(int[] arr,int start,int end,int[] temp)&#123; if(start &lt; end)&#123; int mid = (start + end) &gt;&gt; 1; sort(arr,start,mid,temp); sort(arr,mid+1,end,temp); merge(arr,start,mid,end,temp); &#125;&#125; 合(merge)我们在进行merge操作的时候,是对不同的部分进行合并排序,我们需要利用一个额外temp数组将两个不同部分进行比较依次放入temp数组中.例如: 在我们拆分到不可再分的时候(同样是对于一个数组例如{3,1,4,5,2,7,8,1}) {3,1},我们需要把它们进行比较然后放入temp数组中,然后将临时数组temp放回原始数组arr中去 同样的对于{4,5}也是上述同样的操作. 这两步操作完后arr数组中已经对{3,1,4,5}已经排好序.剩下的就是对原始数组的右半部分进行分合排序 代码123456789101112131415161718192021222324public static void merge(int[] arr,int start,int mid,int end,int[] temp)&#123; int i = start; int j = mid + 1; int cur = 0; while(i &lt;= mid &amp;&amp; j &lt;= end)&#123; if(arr[i] &lt;= arr[j])&#123; temp[cur++] = arr[i++]; &#125; else &#123; temp[cur++] = arr[j++]; &#125; &#125; while (i &lt;= mid)&#123; //将左边剩余元素填充进temp中 temp[cur++] = arr[i++]; &#125; while(j &lt;= end)&#123; //将右序列剩余元素填充进temp中 temp[cur++] = arr[j++]; &#125; cur = 0; while (start &lt;= end)&#123; //将temp中的元素全部拷贝到原数组中 arr[start++] = temp[cur++]; &#125; &#125; 归并排序借鉴一下网上一张图来直观说明大致流程 完整代码: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * @Auther: zy * @Date: 2020/8/5 14:21 * @Description: */public class MergeSort &#123; public static void sort(int[] arr)&#123; int[] temp = new int[arr.length]; sort(arr,0,arr.length-1,temp); //在排序前，先建好一个长度等于原数组长度的临时数组，避免递归中频繁开辟空间 &#125; public static void sort(int[] arr,int start,int end,int[] temp)&#123; if(start &lt; end)&#123; int mid = (start + end) &gt;&gt; 1; sort(arr,start,mid,temp); //左边归并排序，使得左子序列有序 sort(arr,mid+1,end,temp); //右边归并排序，使得右子序列有序 merge(arr,start,mid,end,temp); //将两个有序子数组合并操作 &#125; &#125; public static void merge(int[] arr,int start,int mid,int end,int[] temp)&#123; int i = start; int j = mid + 1; int cur = 0; while(i &lt;= mid &amp;&amp; j &lt;= end)&#123; if(arr[i] &lt;= arr[j])&#123; temp[cur++] = arr[i++]; &#125; else &#123; temp[cur++] = arr[j++]; &#125; &#125; while (i &lt;= mid)&#123; //将左边剩余元素填充进temp中 temp[cur++] = arr[i++]; &#125; while(j &lt;= end)&#123; //将右序列剩余元素填充进temp中 temp[cur++] = arr[j++]; &#125; cur = 0; while (start &lt;= end)&#123; //将temp中的元素全部拷贝到原数组中 arr[start++] = temp[cur++]; &#125; &#125; public static void main(String [] args)&#123; int[] arr = &#123;3,2,1,5,2,31,45,6,2312&#125;; sort(arr); System.out.println(Arrays.toString(arr)); &#125;&#125; 结果: 123[1, 2, 2, 3, 5, 6, 31, 45, 2312]Process finished with exit code 0]]></content>
      <categories>
        <category>study</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 240. FindNumberIn2DArray(Easy)(剑指Offer 04)]]></title>
    <url>%2F2020%2F08%2F03%2FLeetCode-240-FindNumberIn2DArray-%E5%89%91%E6%8C%87Offer-04%2F</url>
    <content type="text"><![CDATA[题目:在一个 n * m的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 示例现有矩阵 matrix 如下： 1234567[ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30]] 给定 target = 5，返回 true。 给定 target = 20，返回 false。 限制0 &lt;= n &lt;= 1000 0 &lt;= m &lt;= 1000 解题思路我们要从一个二维数组的里面找是否存在某一特定值target, 因为该二维数组存在一个规律: 每一行从左到右递增的顺序排序 每一列从上到下递增的顺序排列 从这个规律中我们可以得出几个结论: 左上角的值是每一行最小同时也是每一列最小的 右上角的值是每一行最大的同时是每一列最小的 左下角的值是每一行最小同时也是每一列最大的 右下角的值是每一行最大的同时是每一列最大的 我们比较值可以从这四个角度去当作入口进入数组进行比较.但是其中左上和右下的值都是同为最小或者最大,导致我们进行判定matrix[i][j]与target大小关系时. 例如: matrix[i][j] &gt; target我们就可以判断该target 不在该二维数组中 而当matrix[i][j] &lt; target时 就剩下右边和下方以及重叠区域需要进行判断会很复杂 所以我们选择右上或者左下的值当作入口进行判断.当matrix[i][j] &gt; target 时,我们就可以排除当前列(因为该值为当前列的最小值). 当matrix[i][j] &lt; target时,我们就可以排除当前行(因为该值为当前值的最大值) 这样一来我们每一次进行比较就可以排除一行或者一列直到找到是否存在. 代码12345678910111213141516class Solution &#123; public boolean findNumberIn2DArray(int[][] matrix, int target) &#123; if(matrix.length == 0 || matrix[0].length == 0) return false; int m = matrix.length; int n = matrix[0].length; for(int i = 0; i &lt; m; i++)&#123; int[] col = matrix[i]; for(int j = n-1; j &gt;= 0; j--)&#123; if(matrix[i][j] == target) return true; else if(matrix[i][j] &gt; target) n--; else break; &#125; &#125; return false; &#125;&#125;]]></content>
      <categories>
        <category>study</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 120. MinimunTotal(Medium)]]></title>
    <url>%2F2020%2F07%2F26%2FLeetCode-120-MinimunTotal%2F</url>
    <content type="text"><![CDATA[题目给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。 相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。 示例例如，给定三角形： 123456[ [2], [3,4], [6,5,7], [4,1,8,3]] 自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11） 解题思路DP(自底向上) DP数组,我们需要开辟n+1xm+1的大小.此时的m和n分别为给定List的大小即: 123int m = triangle.size(); int n = triangle.get(m-1).size(); int[][] dp = new int[n+1][m+1]; 然后并初始化最下层为0 也就是dp[n][i] (i : 0-m) 即: 1234//初始化第n层均为0 for(int i = 0;i &lt;= n;i++)&#123; dp[m][i] = 0; &#125; 因为我们是从顶向上进行求解的.我们在得出dp状态转换方程为: 1dp[i][j] = min(dp[i+1][j],dp[i+1][j+1]) + nums[i][j] dp[i][j] 表示从点 (i, j)(i,j) 到底边的最小路径和 这种解法相比自顶向下的递归有一个好处就是不需要在最后的时候查找最小值而是直接返回dp[0][0]就可以了 代码DP(自底向上) 123456789101112131415161718class Solution &#123; public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) &#123; if(triangle == null || triangle.size() == 0) return 0; int m = triangle.size(); int n = triangle.get(m-1).size(); int[][] dp = new int[n+1][m+1]; //初始化第m层均为0 for(int i = 0;i &lt;= n;i++)&#123; dp[m][i] = 0; &#125; for(int i = m-1;i &gt;= 0;i--)&#123; for(int j = 0;j &lt;= i;j++)&#123; dp[i][j] = Math.min(dp[i+1][j],dp[i+1][j+1]) + triangle.get(i).get(j); &#125; &#125; return dp[0][0]; &#125;&#125; 总结目前只把自己懂的一种解法写出来了,还在研究其他大佬的解法.在后面会更新.]]></content>
      <categories>
        <category>study</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 70. ClimbStairs(Easy)]]></title>
    <url>%2F2020%2F07%2F25%2FLeetCode-70-ClimbStairs%2F</url>
    <content type="text"><![CDATA[题目假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定 n 是一个正整数。 在线练习LeetCode: https://leetcode-cn.com/problems/climbing-stairs/ 示例示例1: 12345输入： 2输出： 2解释： 有两种方法可以爬到楼顶。1. 1 阶 + 1 阶2. 2 阶 示例2: 123456输入： 3输出： 3解释： 有三种方法可以爬到楼顶。1. 1 阶 + 1 阶 + 1 阶2. 1 阶 + 2 阶3. 2 阶 + 1 阶 解题思路递归法 很明显当n&lt;=2的时候即爬到第一层第二层有几种方法均为n种,所以我们在最开始进行判断 1if(n &lt;= 2) return n; 如果n&gt;2的话,在爬到n层楼梯需要的方法数是爬到n-1层的方法数+爬到n-2层需要的方法数.即: 1int res = climbStairs(n-1)+climbStairs(n-2); 但是这道题用递归是TLE了.所以我们需要进行优化. 递归法 + 备忘录算法 因为我们在递归的时候总是会重复计算值,试想当这个n很大的时候重复计算的次数会不断增加.所以我们在进行递归的时候需要进行保存计算过的值(可以用HashMap,HashSet或者数组等等). 这里我们开一个数组,数组的长度为n+1,在每次递归的时候对num[n]的值进行判断 1if(nums[n] &gt; 0) 如果nums[n]的值大于0则返回nums[n]否则进行递归求值赋给nums[n]然后再返回nums[n] 动态规划 动态规划就是将一个问题划分成多个子问题.爬第n阶楼梯的方法数量等于 2 部分之和: 爬上 n-1 阶楼梯的方法数量.因为再爬1阶就能到第n阶 爬上 n-2 阶楼梯的方法数量,因为再爬2阶就能到第n阶公式nums[n] = nums[n-1] + nums[n-2] (n &gt; 2) 代码递归法 123456class Solution &#123; public int climbStairs(int n) &#123; if(n &lt;= 2) return n; return climbStairs(n-1)+climbStairs(n-2); &#125;&#125; 递归法 + 备忘录算法 12345678910111213141516class Solution &#123; public int climbStairs(int n) &#123; int[] nums = new int[n+1]; return calculate(n,nums); &#125; public int calculate(int n,int[] nums)&#123; if(n &lt;= 2) return n; if(nums[n] &gt; 0)&#123; return nums[n]; &#125; nums[n] = calculate(n-1,nums) + calculate(n-2,nums); return nums[n]; &#125;&#125; 动态规划 12345678910111213141516class Solution &#123; public int climbStairs(int n) &#123; int[] nums = new int[n+1]; if(n &lt;= 2) return n; return calculate(n,nums); &#125; public int calculate(int n,int[] nums)&#123; nums[1] = 1; nums[2] = 2; for(int i = 3;i &lt; nums.length;i++)&#123; nums[i] = nums[i-1] + nums[i-2]; &#125; return nums[n]; &#125;&#125; 总结这道题在LeetCode上是属于Easy难度的,也是练习DP的第一道题]]></content>
      <categories>
        <category>study</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 145. postorderTraversal(Hard)]]></title>
    <url>%2F2020%2F07%2F14%2FLeetCode-145-postorderTraversal%2F</url>
    <content type="text"><![CDATA[题目给定一个二叉树，返回它的 后序 遍历。 示例12345678输入: [1,null,2,3] 1 \ 2 / 3 输出: [3,2,1] 进阶:递归算法很简单，你可以通过迭代算法完成吗？ 解题思路常规思路 递归 迭代 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; // 1. Recursion // public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; // List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); // if(root == null) return res; // Recursion(root,res); // return res; // &#125; // public void Recursion(TreeNode root,List&lt;Integer&gt; res)&#123; // if(root.left != null) Recursion(root.left,res); // if(root.right != null) Recursion(root.right,res); // res.add(root.val); // &#125; // 2. Iteration public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); if(root == null) return res; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode target = null; while(root != null || !stack.isEmpty())&#123; while(root != null)&#123; stack.push(root); root = root.left; &#125; root = stack.peek(); if(root.right == null || target == root.right)&#123; root = stack.pop(); res.add(root.val); target = root; root = null; &#125;else&#123; root = root.right; &#125; &#125; return res; &#125; &#125;]]></content>
      <categories>
        <category>study</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>BinaryTree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 94. inorderTraversal(Medium)]]></title>
    <url>%2F2020%2F07%2F14%2FLeetCode-94-inorderTraversal%2F</url>
    <content type="text"><![CDATA[题目给定一个二叉树，返回它的 中序 遍历 示例12345678输入: [1,null,2,3] 1 \ 2 / 3输出: [1,3,2] 进阶:递归算法很简单，你可以通过迭代算法完成吗？ 解题思路常规思路 递归 迭代 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; // 1.Recursion public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if(root == null) return res; Recursion(root,res); return res; &#125; public void Recursion(TreeNode cur,List&lt;Integer&gt; res)&#123; if(cur.left != null) Recursion(cur.left,res); res.add(cur.val); if(cur.right != null) Recursion(cur.right,res); &#125; // 2. Iteration // public List&lt;Integer&gt; inorderTraversal(TreeNode root)&#123; // List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); // if(root == null) return res; // Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); // while(root != null || !stack.isEmpty())&#123; // if(root != null)&#123; // stack.push(root); // root = root.left; // &#125; // else&#123; // root = stack.pop(); // res.add(root.val); // root = root.right; // &#125; // &#125; // return res; // &#125;&#125;]]></content>
      <categories>
        <category>study</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>BinaryTree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 144. preorderTraversal(Medium)]]></title>
    <url>%2F2020%2F07%2F14%2FLeetCode-144-preorderTraversal%2F</url>
    <content type="text"><![CDATA[题目给定一个二叉树，返回它的 前序遍历 示例12345678输入: [1,null,2,3] 1 \ 2 / 3 输出: [1,2,3] 进阶:递归算法很简单，你可以通过迭代算法完成吗？ 解题思路基本思想 递归遍历(Recursion) 迭代遍历(Iteration) 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; // 1. Recursion // public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; // List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); // if(root == null) return res; // Recursion(root,res); // return res; // &#125; // public void Recursion(TreeNode cur,List&lt;Integer&gt; res)&#123; // res.add(cur.val); // if(cur.left != null) Recursion(cur.left,res); // if(cur.right != null) Recursion(cur.right,res); // &#125; // 2. Iteration public List&lt;Integer&gt; preorderTraversal(TreeNode root)&#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if(root == null) return res; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); while(root != null || !stack.isEmpty())&#123; if(root != null)&#123; res.add(root.val); stack.push(root); root = root.left; &#125;else&#123; root = stack.pop(); root = root.right; &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>study</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>BinaryTree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 206. ReverseList (Medium)]]></title>
    <url>%2F2020%2F07%2F14%2FLeetCode-206-ReverseList%2F</url>
    <content type="text"><![CDATA[题目反转一个单链表。 示例示例: 12输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 解题思路迭代法 + 双指针 在循环中需要做的事是要将当前节点指向前一个节点,所以就需要定义两个指针cur pre分别表示当前节点和前继节点.与此同时我们还需要在循环中用一个next来保存cur的后继节点避免出现节点丢失 Time complexity O(n)Space complexity O(1) 递归法 递归反转链表相比迭代是有一定的难度的我们需要明确这个函数的作用是什么:参数为头指针,反转链表后返回翻转后的链表 最难理解的是比如:4和5需要反转, 4-&gt;5 此时的cur是4,需要将cur.next.next = cur 将5的next指向4 图下是我在LeetCode讨论区找到一个gif方便理解: Time complexity O(n)Space complexity O(n) 代码迭代法 + 双指针 12345678910111213class Solution &#123; public static ListNode reverseListIterate(ListNode head) &#123; ListNode cur = head; ListNode pre = null; while(cur != null)&#123; ListNode next = cur.next; cur.next = pre; pre = cur; cur = next; &#125; return pre; &#125;&#125; 递归法 123456789class Solution &#123; public static ListNode reverseListRecursion(ListNode head)&#123; if(head == null || head.next == null) return head; ListNode temp = reverseListRecursion(head.next); head.next.next = head; head.next = null; return temp; &#125;&#125; 总结反转链表这个题最主要的还是递归方法的难以理解, 这也是递归经典题.在以后还是需要多加练习多总结才能帮助理解. 后面还要反转链表前n项 以及 反转链表部分项 等类似的题就更新到下一篇文章]]></content>
      <categories>
        <category>study</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 26. RemoveDuplicates (Easy)]]></title>
    <url>%2F2020%2F06%2F30%2FLeetCode_26_removeDuplicates%2F</url>
    <content type="text"><![CDATA[题目给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。 在线练习you can practice online:LeetCode 示例示例一: 12345给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。 示例二: 12345给定 nums = [0,0,1,1,1,2,2,3,3,4],函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。你不需要考虑数组中超出新长度后面的元素。 解题思路双指针法定义慢指针i初始化为0 , 快指针j初始化为1.每一次遍历的时候,判断nums[i]与nums[j]是否相等,如果相等则j++.若不等则先i++然后将nums[j]赋值给nums[i] Time complexity O(n)Space complexity O(1) 代码1234567891011class Solution &#123; public int removeDuplicates(int[] nums) &#123; int i = 0; for(int j = 1;j &lt; nums.length;j++)&#123; if(nums[i] != nums[j])&#123; nums[++i] = nums[j]; &#125; &#125; return i+1; &#125;&#125;]]></content>
      <categories>
        <category>study</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 2. Add Two Numbers (Medium)]]></title>
    <url>%2F2020%2F06%2F29%2FLeetCode_2_%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0%2F</url>
    <content type="text"><![CDATA[题目给出两个非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照逆序的方式存储的，并且它们的每个节点只能存储一位数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0开头。 示例123输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 解题思路因为我们之后需要输出的是头节点,所以这里创建了虚拟头节点res用来最后输出,和当前节点cur用来进行两数相加操作 定义carry表示相加是否有进位,初始为0 while,判断的条件是两个链表的-&gt;next指针域是否为空 在循环体中,首先用了一个三元运算符 如果l1,l2不为空则将各自的val赋值给n1 n2,否则赋值0; 同时要判断是否有进位 在循环体结束后,判断最后一位是否有进位,如果有则在链表的最后加上值为1的结点. Time complexity O(max(n,m))Space complexity O(max(n,m)) 代码12345678910111213141516171819202122232425262728/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode* res = new ListNode(-1); //定义虚拟头节点 ListNode* cur = res; int carry = 0; while(l1||l2)&#123; int n1 = l1? l1-&gt;val : 0; int n2 = l2? l2-&gt;val : 0; int sum = n1 + n2 + carry; carry = sum/10; cur-&gt;next = new ListNode(sum%10); cur = cur-&gt;next; if(l1) l1 = l1-&gt;next; if(l2) l2 = l2-&gt;next; &#125; if(carry) cur-&gt;next = new ListNode(1); //在循环结束后如果有进位,则在最前面添加一个值为1的节点 return res-&gt;next; &#125;&#125;;]]></content>
      <categories>
        <category>study</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 1. TwoSum (Easy)]]></title>
    <url>%2F2020%2F06%2F28%2FLeetCode_1_%E4%B8%A4%E6%95%B0%E5%92%8C%2F</url>
    <content type="text"><![CDATA[题目给定一个整数数组 nums和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。 示例:1234给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 解题思路解法1: 一开始我脑海里能想到的就是暴力求解: 求和为target的两个整数,那么两次for循环 先在第一个循环里找第一个数然后在第二个循环数不断进行判断两个数之和是否等于target因为这里进行了嵌套使用了两个for循环 这样虽然节省空间,但是时间复杂度:O(n²) 解法2: 随后想到用unordered_map进行一次遍历将数组里面的值与下标以key:value保存在unordered_map里面,然后再通过一次循环查看target-nums.at(i)的差值是否在hash_map里面存在,如果存在还要进行判断下标是否为i(是否已遍历),如果都满足break跳出循环,则将两个数的下标index push_back进res数组里. 这样使用到了unordered_map, unordered_map相当于HashMap。无论从查找、插入上来说，unordered_map的效率都优于hash_map，更优于map Time complexity O(n) 代码解法1: (暴力法) 12345678910111213141516171819class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; //暴力法 int leftNum = 0; vector&lt;int&gt; res; for(int i=0;i&lt;nums.size();i++)&#123; leftNum = nums.at(i); for(int j=i+1;j&lt;nums.size();j++)&#123; if(leftNum + nums.at(j) == target)&#123; res.push_back(i); res.push_back(j); break; &#125; &#125; &#125; return res; &#125;&#125;; 解法2: (unordered_map) 1234567891011121314151617181920class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; //unordered_map unordered_map &lt;int,int&gt; numsMap; vector&lt;int&gt; res; for(int i=0;i&lt;nums.size();i++)&#123; numsMap[nums.at(i)] = i; &#125; for(int i=0;i&lt;nums.size();i++)&#123; int k = target-nums.at(i); if(numsMap.count(k) &amp;&amp; numsMap[k] != i)&#123; res.push_back(i); res.push_back(numsMap[k]); break; &#125; &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>study</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 566. Reshape the Matrix (Easy)]]></title>
    <url>%2F2020%2F06%2F27%2FLeetCode_566_%E9%87%8D%E5%A1%91%E7%9F%A9%E9%98%B5%2F</url>
    <content type="text"><![CDATA[题目:在MATLAB中，有一个非常有用的函数 reshape，它可以将一个矩阵重塑为另一个大小不同的新矩阵，但保留其原始数据。 给出一个由二维数组表示的矩阵，以及两个正整数r和c，分别表示想要的重构的矩阵的行数和列数。 重构后的矩阵需要将原始矩阵的所有元素以相同的行遍历顺序填充。 如果具有给定参数的reshape操作是可行且合理的，则输出新的重塑矩阵；否则，输出原始矩阵。 解题思路:获取nums的大小分别为:nums.size()以及nums[0].size() 然后进行判断是否能够重塑另一个rc的矩阵:`nums.size() * nums[0].size() ==? rc如果不相等则返回之前的矩阵nums`. 如果相等则初始化一个矩阵res,然后通过行遍历顺序进行重新赋值 示例:123456789输入: nums = [[1,2], [3,4]]r = 1, c = 4输出: [[1,2,3,4]]解释:行遍历nums的结果是 [1,2,3,4]。新的矩阵是 1 * 4 矩阵, 用之前的元素值一行一行填充新矩阵。 12345678910输入: nums = [[1,2], [3,4]]r = 2, c = 4输出: [[1,2], [3,4]]解释:没有办法将 2 * 2 矩阵转化为 2 * 4 矩阵。 所以输出原矩阵。 说明: 给定矩阵的宽和高范围在 [1, 100]。 给定的 r 和 c 都是正数。 代码1234567891011121314151617181920212223class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; matrixReshape(vector&lt;vector&lt;int&gt;&gt;&amp; nums, int r, int c) &#123; int m = nums[0].size(); int n = nums.size(); if(m*n != r*c) return nums; int x = 0; int y = 0; vector&lt;vector&lt;int&gt;&gt; res(r,vector&lt;int&gt;(c)); for(int i=0;i&lt;r;i++)&#123; for(int j=0;j&lt;c;j++)&#123; res[i][j] = nums[x][y]; y++; if(y == m)&#123; x++; y=0; &#125; &#125; &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>study</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 283. Move Zeroes (Easy)]]></title>
    <url>%2F2020%2F06%2F26%2FLeetCode_283_moveZeroes%2F</url>
    <content type="text"><![CDATA[题目:给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 示例:12输入: [0,1,0,3,12]输出: [1,3,12,0,0] 说明: 必须在原数组上操作，不能拷贝额外的数组。 尽量减少操作次数。 解题思路遍历nums的同时判断nums.at(i)是否为0,如果是那么就删除这个值然后在数组的末尾push_back0进去(tips:每进行删除然后push_back后不要将遍历变量i++,例如数组中0-0-1,第一项删除0后,变化后的nums为&#39;0-1-0&#39;,也就是第二次遍历后会判断为1而不是0,所以遍历变量不需要进行自增.而如果不为0,则进行i++) 代码12345678910111213141516class Solution &#123;public: void moveZeroes(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); for(int i=0;i&lt;n;)&#123; if(nums.at(i)==0)&#123; nums.erase(nums.begin()+i); nums.push_back(0); n--; &#125;else i++; &#125; for(int i=0;i&lt;nums.size();i++)&#123; cout &lt;&lt; nums.at(i) ; &#125; &#125;&#125;;]]></content>
      <categories>
        <category>study</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 724. Find Pivol Index (Easy)]]></title>
    <url>%2F2020%2F06%2F26%2FLeetCode_724_%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E5%BF%83%E7%B4%A2%E5%BC%95%2F</url>
    <content type="text"><![CDATA[题目:给定一个整数类型的数组nums，请编写一个能够返回数组 “中心索引” 的方法。 我们是这样定义数组 中心索引 的：数组中心索引的左侧所有元素相加的和等于右侧所有元素相加的和。 如果数组不存在中心索引，那么我们应该返回 -1。如果数组有多个中心索引，那么我们应该返回最靠近左边的那一个。 示例:123456输入：nums = [1, 7, 3, 6, 5, 6]输出：3解释：索引 3 (nums[3] = 6) 的左侧数之和 (1 + 7 + 3 = 11)，与右侧数之和 (5 + 6 = 11) 相等。同时, 3 也是第一个符合要求的中心索引。 12345输入：nums = [1, 2, 3]输出：-1解释：数组中不存在满足此条件的中心索引。 解题思路这里我们需要求的左边和以及右边的和进行比较,在进行遍历的时候对左边和进行求解是比较方便的.直接初始化leftSum=0,然后每次遍历之后可以+=进行累加求的leftSum. 最主要的还是通过leftSum求的rightSum(rightSum = sum(数组的和) - num.at(i) - leftSum) 每次循环先进行求的rightSum 然后与leftSum进行比较,如果相等则return 当前的次序i.直到数组遍历结束未找到左右和相等则返回-1. 代码1234567891011121314151617class Solution &#123;public: int pivotIndex(vector&lt;int&gt;&amp; nums) &#123; int sum = 0; int leftSum = 0; int rightSum = 0; for(int i=0;i&lt;nums.size();i++)&#123; sum += nums.at(i); &#125; for(int i=0;i&lt;nums.size();i++)&#123; rightSum = sum-nums.at(i)-leftSum; if(rightSum == leftSum) return i; leftSum += nums.at(i); &#125; return -1; &#125;&#125;;]]></content>
      <categories>
        <category>study</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 1470. Shuffle the Array (Easy)]]></title>
    <url>%2F2020%2F06%2F25%2FLeetCode_1470_%E9%87%8D%E6%96%B0%E6%8E%92%E5%88%97%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[题目给你一个数组 nums ，数组中有 2n 个元素，按 [x1,x2,...,xn,y1,y2,...,yn] 的格式排列。 请你将数组按 [x1,y1,x2,y2,...,xn,yn] 格式重新排列，返回重排后的数组。 示例示例 1： 123输入：nums = [2,5,1,3,4,7], n = 3输出：[2,3,5,4,1,7] 解释：由于 x1=2, x2=5, x3=1, y1=3, y2=4, y3=7 ，所以答案为 [2,3,5,4,1,7] 示例 2： 12输入：nums = [1,2,3,4,4,3,2,1], n = 4输出：[1,4,2,3,3,2,4,1] 示例 3： 12输入：nums = [1,1,2,2], n = 2输出：[1,2,1,2] 解题思路这里新建一个vector res,然后通过一次循环i-&gt;[0,n)将num[i]以及num[i+n]插入到新建的res中 (这里num[i]与num[i+n]分别代表题干表示的x1,y1)这样res中就保存了x1,y1,x2,y2等等..然后return 就完事儿了 代码1234567891011121314class Solution &#123;public: vector&lt;int&gt; shuffle(vector&lt;int&gt;&amp; nums, int n) &#123; vector&lt;int&gt; res; for(int i=0;i&lt;n;i++)&#123; res.push_back(nums[i]); res.push_back(nums[i+n]); &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>study</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 1486. XOR Operation in an Array (Easy)]]></title>
    <url>%2F2020%2F06%2F24%2FLeetCode_1486_%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97%2F</url>
    <content type="text"><![CDATA[题目:给你两个整数，n 和 start 。 数组 nums 定义为：nums[i] = start + 2*i（下标从 0 开始）且 n == nums.length 。 请返回 nums 中所有元素按位异或（XOR）后得到的结果。 示例:1234输入：n = 5, start = 0输出：8解释：数组 nums 为 [0, 2, 4, 6, 8]，其中 (0 ^ 2 ^ 4 ^ 6 ^ 8) = 8 。 &quot;^&quot; 为按位异或 XOR 运算符。 123输入：n = 4, start = 3输出：8解释：数组 nums 为 [3, 5, 7, 9]，其中 (3 ^ 5 ^ 7 ^ 9) = 8. 解题思路首先得明白按位异或(XOR)是什么: 参与运算的两个值，==如果两个相应位相同，则结果为0==，否则为1。即：0^0=0， 1^0=1， 0^1=1， 1^1=0 例如: 1235: 000001013: 000001005^3 = 00000001 -&gt; 1 我们这里只需要在一个for循环里面进行对每个数累计求异或运算 ^=即可 代码代码很简单 12345678910class Solution &#123;public: int xorOperation(int n, int start) &#123; int result = 0; for(int i=0; i&lt;n; i++)&#123; result ^= start + 2*i; &#125; return result; &#125;&#125;; 总结这道题是很简单的一道题.做这个题解的目的呢主要是记录一下 希望自己能慢慢在leetcode上刷题来提升自己去解决更复杂的问题.]]></content>
      <categories>
        <category>study</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
</search>
